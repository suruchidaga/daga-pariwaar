{"version":3,"file":"static/js/565.272787e4.chunk.js","mappings":"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","sources":["../node_modules/@supabase/functions-js/src/helper.ts","../node_modules/@babel/runtime/helpers/esm/set.js","../node_modules/@babel/runtime/helpers/esm/superPropBase.js","../node_modules/@babel/runtime/helpers/esm/construct.js","../node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js","../node_modules/@babel/runtime/helpers/esm/isNativeFunction.js","../node_modules/@supabase/functions-js/src/types.ts","../node_modules/@supabase/realtime-js/src/lib/constants.ts","../node_modules/@supabase/functions-js/src/FunctionsClient.ts","../node_modules/@supabase/postgrest-js/src/PostgrestTransformBuilder.ts","../node_modules/@supabase/postgrest-js/src/PostgrestBuilder.ts","../node_modules/@supabase/postgrest-js/src/PostgrestFilterBuilder.ts","../node_modules/@supabase/postgrest-js/src/PostgrestQueryBuilder.ts","../node_modules/@supabase/postgrest-js/src/constants.ts","../node_modules/@supabase/postgrest-js/src/version.ts","../node_modules/@supabase/postgrest-js/src/PostgrestClient.ts","../node_modules/@supabase/realtime-js/src/lib/version.ts","../node_modules/@supabase/realtime-js/src/RealtimePresence.ts","../node_modules/@supabase/realtime-js/src/lib/timer.ts","../node_modules/@supabase/realtime-js/src/lib/serializer.ts","../node_modules/@supabase/realtime-js/src/lib/push.ts","../node_modules/@supabase/realtime-js/src/lib/transformers.ts","../node_modules/@supabase/realtime-js/src/RealtimeChannel.ts","../node_modules/@supabase/realtime-js/src/RealtimeClient.ts","../node_modules/@supabase/storage-js/src/lib/errors.ts","../node_modules/@supabase/storage-js/src/lib/helpers.ts","../node_modules/@supabase/storage-js/src/lib/fetch.ts","../node_modules/@supabase/storage-js/src/packages/StorageFileApi.ts","../node_modules/@supabase/storage-js/src/lib/constants.ts","../node_modules/@supabase/storage-js/src/lib/version.ts","../node_modules/@supabase/storage-js/src/packages/StorageBucketApi.ts","../node_modules/@supabase/storage-js/src/StorageClient.ts","../node_modules/@supabase/supabase-js/src/lib/constants.ts","../node_modules/@supabase/supabase-js/src/lib/version.ts","../node_modules/@supabase/supabase-js/src/lib/fetch.ts","../node_modules/@supabase/gotrue-js/src/lib/helpers.ts","../node_modules/@supabase/gotrue-js/src/lib/errors.ts","../node_modules/@supabase/gotrue-js/src/lib/fetch.ts","../node_modules/@supabase/gotrue-js/src/GoTrueAdminApi.ts","../node_modules/@supabase/gotrue-js/src/lib/constants.ts","../node_modules/@supabase/gotrue-js/src/lib/version.ts","../node_modules/@supabase/gotrue-js/src/lib/local-storage.ts","../node_modules/@supabase/gotrue-js/src/lib/polyfills.ts","../node_modules/@supabase/gotrue-js/src/GoTrueClient.ts","../node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts","../node_modules/@supabase/supabase-js/src/SupabaseClient.ts","../node_modules/@supabase/supabase-js/src/lib/helpers.ts","../node_modules/@supabase/supabase-js/src/index.ts","../node_modules/cross-fetch/dist/browser-ponyfill.js","../node_modules/es5-ext/global.js","../node_modules/websocket/lib/browser.js","../node_modules/websocket/lib/version.js"],"sourcesContent":["import { Fetch } from './types'\n\nexport const resolveFetch = (customFetch?: Fetch): Fetch => {\n  let _fetch: Fetch\n  if (customFetch) {\n    _fetch = customFetch\n  } else if (typeof fetch === 'undefined') {\n    _fetch = async (...args) => await (await import('cross-fetch')).fetch(...args)\n  } else {\n    _fetch = fetch\n  }\n  return (...args) => _fetch(...args)\n}\n","import superPropBase from \"./superPropBase.js\";\nimport defineProperty from \"./defineProperty.js\";\n\nfunction set(target, property, value, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.set) {\n    set = Reflect.set;\n  } else {\n    set = function set(target, property, value, receiver) {\n      var base = superPropBase(target, property);\n      var desc;\n\n      if (base) {\n        desc = Object.getOwnPropertyDescriptor(base, property);\n\n        if (desc.set) {\n          desc.set.call(receiver, value);\n          return true;\n        } else if (!desc.writable) {\n          return false;\n        }\n      }\n\n      desc = Object.getOwnPropertyDescriptor(receiver, property);\n\n      if (desc) {\n        if (!desc.writable) {\n          return false;\n        }\n\n        desc.value = value;\n        Object.defineProperty(receiver, property, desc);\n      } else {\n        defineProperty(receiver, property, value);\n      }\n\n      return true;\n    };\n  }\n\n  return set(target, property, value, receiver);\n}\n\nexport default function _set(target, property, value, receiver, isStrict) {\n  var s = set(target, property, value, receiver || target);\n\n  if (!s && isStrict) {\n    throw new Error('failed to set property');\n  }\n\n  return value;\n}","import getPrototypeOf from \"./getPrototypeOf.js\";\nexport default function _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}","import setPrototypeOf from \"./setPrototypeOf.js\";\nimport isNativeReflectConstruct from \"./isNativeReflectConstruct.js\";\nexport default function _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    _construct = Reflect.construct.bind();\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}","import getPrototypeOf from \"./getPrototypeOf.js\";\nimport setPrototypeOf from \"./setPrototypeOf.js\";\nimport isNativeFunction from \"./isNativeFunction.js\";\nimport construct from \"./construct.js\";\nexport default function _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return construct(Class, arguments, getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}","export default function _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}","export type Fetch = typeof fetch\n\n/**\n * Response format\n *\n */\nexport interface FunctionsResponseSuccess<T> {\n  data: T\n  error: null\n}\nexport interface FunctionsResponseFailure {\n  data: null\n  error: any\n}\nexport type FunctionsResponse<T> = FunctionsResponseSuccess<T> | FunctionsResponseFailure\n\nexport class FunctionsError extends Error {\n  context: any\n  constructor(message: string, name = 'FunctionsError', context?: any) {\n    super(message)\n    super.name = name\n    this.context = context\n  }\n}\n\nexport class FunctionsFetchError extends FunctionsError {\n  constructor(context: any) {\n    super('Failed to send a request to the Edge Function', 'FunctionsFetchError', context)\n  }\n}\n\nexport class FunctionsRelayError extends FunctionsError {\n  constructor(context: any) {\n    super('Relay Error invoking the Edge Function', 'FunctionsRelayError', context)\n  }\n}\n\nexport class FunctionsHttpError extends FunctionsError {\n  constructor(context: any) {\n    super('Edge Function returned a non-2xx status code', 'FunctionsHttpError', context)\n  }\n}\n\nexport type FunctionInvokeOptions = {\n  /**\n   * object representing the headers to send with the request\n   * */\n  headers?: { [key: string]: string }\n  /**\n   * the body of the request\n   */\n  body?:\n    | File\n    | Blob\n    | ArrayBuffer\n    | FormData\n    | ReadableStream<Uint8Array>\n    | Record<string, any>\n    | string\n}\n","import { version } from './version'\n\nexport const DEFAULT_HEADERS = { 'X-Client-Info': `realtime-js/${version}` }\n\nexport const VSN: string = '1.0.0'\n\nexport const DEFAULT_TIMEOUT = 10000\n\nexport const WS_CLOSE_NORMAL = 1000\n\nexport enum SOCKET_STATES {\n  connecting = 0,\n  open = 1,\n  closing = 2,\n  closed = 3,\n}\n\nexport enum CHANNEL_STATES {\n  closed = 'closed',\n  errored = 'errored',\n  joined = 'joined',\n  joining = 'joining',\n  leaving = 'leaving',\n}\n\nexport enum CHANNEL_EVENTS {\n  close = 'phx_close',\n  error = 'phx_error',\n  join = 'phx_join',\n  reply = 'phx_reply',\n  leave = 'phx_leave',\n  access_token = 'access_token',\n}\n\nexport enum TRANSPORTS {\n  websocket = 'websocket',\n}\n\nexport enum CONNECTION_STATE {\n  Connecting = 'connecting',\n  Open = 'open',\n  Closing = 'closing',\n  Closed = 'closed',\n}\n","import { resolveFetch } from './helper'\nimport {\n  Fetch,\n  FunctionsFetchError,\n  FunctionsHttpError,\n  FunctionsRelayError,\n  FunctionsResponse,\n  FunctionInvokeOptions,\n} from './types'\n\nexport class FunctionsClient {\n  protected url: string\n  protected headers: Record<string, string>\n  protected fetch: Fetch\n\n  constructor(\n    url: string,\n    {\n      headers = {},\n      customFetch,\n    }: {\n      headers?: Record<string, string>\n      customFetch?: Fetch\n    } = {}\n  ) {\n    this.url = url\n    this.headers = headers\n    this.fetch = resolveFetch(customFetch)\n  }\n\n  /**\n   * Updates the authorization header\n   * @param token - the new jwt token sent in the authorisation header\n   */\n  setAuth(token: string) {\n    this.headers.Authorization = `Bearer ${token}`\n  }\n\n  /**\n   * Invokes a function\n   * @param functionName - the name of the function to invoke\n   */\n  async invoke<T = any>(\n    functionName: string,\n    invokeOptions: FunctionInvokeOptions = {}\n  ): Promise<FunctionsResponse<T>> {\n    try {\n      const { headers, body: functionArgs } = invokeOptions\n\n      let _headers: Record<string, string> = {}\n      let body: any\n      if (\n        functionArgs &&\n        ((headers && !Object.prototype.hasOwnProperty.call(headers, 'Content-Type')) || !headers)\n      ) {\n        if (\n          (typeof Blob !== 'undefined' && functionArgs instanceof Blob) ||\n          functionArgs instanceof ArrayBuffer\n        ) {\n          // will work for File as File inherits Blob\n          // also works for ArrayBuffer as it is the same underlying structure as a Blob\n          _headers['Content-Type'] = 'application/octet-stream'\n          body = functionArgs\n        } else if (typeof functionArgs === 'string') {\n          // plain string\n          _headers['Content-Type'] = 'text/plain'\n          body = functionArgs\n        } else if (typeof FormData !== 'undefined' && functionArgs instanceof FormData) {\n          // don't set content-type headers\n          // Request will automatically add the right boundary value\n          body = functionArgs\n        } else {\n          // default, assume this is JSON\n          _headers['Content-Type'] = 'application/json'\n          body = JSON.stringify(functionArgs)\n        }\n      }\n\n      const response = await this.fetch(`${this.url}/${functionName}`, {\n        method: 'POST',\n        // headers priority is (high to low):\n        // 1. invoke-level headers\n        // 2. client-level headers\n        // 3. default Content-Type header\n        headers: { ..._headers, ...this.headers, ...headers },\n        body,\n      }).catch((fetchError) => {\n        throw new FunctionsFetchError(fetchError)\n      })\n\n      const isRelayError = response.headers.get('x-relay-error')\n      if (isRelayError && isRelayError === 'true') {\n        throw new FunctionsRelayError(response)\n      }\n\n      if (!response.ok) {\n        throw new FunctionsHttpError(response)\n      }\n\n      let responseType = (response.headers.get('Content-Type') ?? 'text/plain').split(';')[0].trim()\n      let data: any\n      if (responseType === 'application/json') {\n        data = await response.json()\n      } else if (responseType === 'application/octet-stream') {\n        data = await response.blob()\n      } else if (responseType === 'multipart/form-data') {\n        data = await response.formData()\n      } else {\n        // default to text\n        data = await response.text()\n      }\n\n      return { data, error: null }\n    } catch (error) {\n      return { data: null, error }\n    }\n  }\n}\n","import PostgrestBuilder from './PostgrestBuilder'\nimport { GetResult } from './select-query-parser'\nimport {\n  GenericSchema,\n  PostgrestMaybeSingleResponse,\n  PostgrestResponse,\n  PostgrestSingleResponse,\n} from './types'\n\nexport default class PostgrestTransformBuilder<\n  Schema extends GenericSchema,\n  Row extends Record<string, unknown>,\n  Result\n> extends PostgrestBuilder<Result> {\n  /**\n   * Perform a SELECT on the query result.\n   *\n   * By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not\n   * return modified rows. By calling this method, modified rows are returned in\n   * `data`.\n   *\n   * @param columns - The columns to retrieve, separated by commas\n   */\n  select<Query extends string = '*', NewResult = GetResult<Schema, Row, Query>>(\n    columns?: Query\n  ): PostgrestTransformBuilder<Schema, Row, NewResult> {\n    // Remove whitespaces except when quoted\n    let quoted = false\n    const cleanedColumns = (columns ?? '*')\n      .split('')\n      .map((c) => {\n        if (/\\s/.test(c) && !quoted) {\n          return ''\n        }\n        if (c === '\"') {\n          quoted = !quoted\n        }\n        return c\n      })\n      .join('')\n    this.url.searchParams.set('select', cleanedColumns)\n    if (this.headers['Prefer']) {\n      this.headers['Prefer'] += ','\n    }\n    this.headers['Prefer'] += 'return=representation'\n    return this as unknown as PostgrestTransformBuilder<Schema, Row, NewResult>\n  }\n\n  /**\n   * Order the query result by `column`.\n   *\n   * You can call this method multiple times to order by multiple columns.\n   *\n   * You can order foreign tables, but it doesn't affect the ordering of the\n   * current table.\n   *\n   * @param column - The column to order by\n   * @param options - Named parameters\n   * @param options.ascending - If `true`, the result will be in ascending order\n   * @param options.nullsFirst - If `true`, `null`s appear first. If `false`,\n   * `null`s appear last.\n   * @param options.foreignTable - Set this to order a foreign table by foreign\n   * columns\n   */\n  order<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    options?: { ascending?: boolean; nullsFirst?: boolean; foreignTable?: undefined }\n  ): this\n  order(\n    column: string,\n    options?: { ascending?: boolean; nullsFirst?: boolean; foreignTable: string }\n  ): this\n  order(\n    column: string,\n    {\n      ascending = true,\n      nullsFirst,\n      foreignTable,\n    }: { ascending?: boolean; nullsFirst?: boolean; foreignTable?: string } = {}\n  ): this {\n    const key = foreignTable ? `${foreignTable}.order` : 'order'\n    const existingOrder = this.url.searchParams.get(key)\n\n    this.url.searchParams.set(\n      key,\n      `${existingOrder ? `${existingOrder},` : ''}${column}.${ascending ? 'asc' : 'desc'}${\n        nullsFirst === undefined ? '' : nullsFirst ? '.nullsfirst' : '.nullslast'\n      }`\n    )\n    return this\n  }\n\n  /**\n   * Limit the query result by `count`.\n   *\n   * @param count - The maximum number of rows to return\n   * @param options - Named parameters\n   * @param options.foreignTable - Set this to limit rows of foreign tables\n   * instead of the current table\n   */\n  limit(count: number, { foreignTable }: { foreignTable?: string } = {}): this {\n    const key = typeof foreignTable === 'undefined' ? 'limit' : `${foreignTable}.limit`\n    this.url.searchParams.set(key, `${count}`)\n    return this\n  }\n\n  /**\n   * Limit the query result by `from` and `to` inclusively.\n   *\n   * @param from - The starting index from which to limit the result\n   * @param to - The last index to which to limit the result\n   * @param options - Named parameters\n   * @param options.foreignTable - Set this to limit rows of foreign tables\n   * instead of the current table\n   */\n  range(from: number, to: number, { foreignTable }: { foreignTable?: string } = {}): this {\n    const keyOffset = typeof foreignTable === 'undefined' ? 'offset' : `${foreignTable}.offset`\n    const keyLimit = typeof foreignTable === 'undefined' ? 'limit' : `${foreignTable}.limit`\n    this.url.searchParams.set(keyOffset, `${from}`)\n    // Range is inclusive, so add 1\n    this.url.searchParams.set(keyLimit, `${to - from + 1}`)\n    return this\n  }\n\n  /**\n   * Set the AbortSignal for the fetch request.\n   *\n   * @param signal - The AbortSignal to use for the fetch request\n   */\n  abortSignal(signal: AbortSignal): this {\n    this.signal = signal\n    return this\n  }\n\n  /**\n   * Return `data` as a single object instead of an array of objects.\n   *\n   * Query result must be one row (e.g. using `.limit(1)`), otherwise this\n   * returns an error.\n   */\n  single(): PromiseLike<PostgrestSingleResponse<Result>> {\n    this.headers['Accept'] = 'application/vnd.pgrst.object+json'\n    return this as PromiseLike<PostgrestSingleResponse<Result>>\n  }\n\n  /**\n   * Return `data` as a single object instead of an array of objects.\n   *\n   * Query result must be zero or one row (e.g. using `.limit(1)`), otherwise\n   * this returns an error.\n   */\n  maybeSingle(): PromiseLike<PostgrestMaybeSingleResponse<Result>> {\n    this.headers['Accept'] = 'application/vnd.pgrst.object+json'\n    this.allowEmpty = true\n    return this as PromiseLike<PostgrestMaybeSingleResponse<Result>>\n  }\n\n  /**\n   * Return `data` as a string in CSV format.\n   */\n  csv(): PromiseLike<PostgrestSingleResponse<string>> {\n    this.headers['Accept'] = 'text/csv'\n    return this as PromiseLike<PostgrestSingleResponse<string>>\n  }\n\n  /**\n   * Return `data` as an object in [GeoJSON](https://geojson.org) format.\n   */\n  geojson(): PromiseLike<PostgrestSingleResponse<Record<string, unknown>>> {\n    this.headers['Accept'] = 'application/geo+json'\n    return this as PromiseLike<PostgrestSingleResponse<Record<string, unknown>>>\n  }\n\n  /**\n   * Return `data` as the EXPLAIN plan for the query.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.analyze - If `true`, the query will be executed and the\n   * actual run time will be returned\n   *\n   * @param options.verbose - If `true`, the query identifier will be returned\n   * and `data` will include the output columns of the query\n   *\n   * @param options.settings - If `true`, include information on configuration\n   * parameters that affect query planning\n   *\n   * @param options.buffers - If `true`, include information on buffer usage\n   *\n   * @param options.wal - If `true`, include information on WAL record generation\n   *\n   * @param options.format - The format of the output, can be `\"text\"` (default)\n   * or `\"json\"`\n   */\n  explain({\n    analyze = false,\n    verbose = false,\n    settings = false,\n    buffers = false,\n    wal = false,\n    format = 'text',\n  }: {\n    analyze?: boolean\n    verbose?: boolean\n    settings?: boolean\n    buffers?: boolean\n    wal?: boolean\n    format?: 'json' | 'text'\n  } = {}):\n    | PromiseLike<PostgrestResponse<Record<string, unknown>>>\n    | PromiseLike<PostgrestSingleResponse<string>> {\n    const options = [\n      analyze ? 'analyze' : null,\n      verbose ? 'verbose' : null,\n      settings ? 'settings' : null,\n      buffers ? 'buffers' : null,\n      wal ? 'wal' : null,\n    ]\n      .filter(Boolean)\n      .join('|')\n    // An Accept header can carry multiple media types but postgrest-js always sends one\n    const forMediatype = this.headers['Accept']\n    this.headers[\n      'Accept'\n    ] = `application/vnd.pgrst.plan+${format}; for=\"${forMediatype}\"; options=${options};`\n    if (format === 'json') return this as PromiseLike<PostgrestResponse<Record<string, unknown>>>\n    else return this as PromiseLike<PostgrestSingleResponse<string>>\n  }\n\n  /**\n   * Rollback the query.\n   *\n   * `data` will still be returned, but the query is not committed.\n   */\n  rollback(): this {\n    if ((this.headers['Prefer'] ?? '').trim().length > 0) {\n      this.headers['Prefer'] += ',tx=rollback'\n    } else {\n      this.headers['Prefer'] = 'tx=rollback'\n    }\n    return this\n  }\n\n  /**\n   * Override the type of the returned `data`.\n   *\n   * @typeParam NewResult - The new result type to override with\n   */\n  returns<NewResult>(): PostgrestTransformBuilder<Schema, Row, NewResult> {\n    return this as unknown as PostgrestTransformBuilder<Schema, Row, NewResult>\n  }\n}\n","import crossFetch from 'cross-fetch'\n\nimport type { Fetch, PostgrestResponse } from './types'\n\nexport default abstract class PostgrestBuilder<Result>\n  implements PromiseLike<PostgrestResponse<Result>>\n{\n  protected method: 'GET' | 'HEAD' | 'POST' | 'PATCH' | 'DELETE'\n  protected url: URL\n  protected headers: Record<string, string>\n  protected schema?: string\n  protected body?: unknown\n  protected shouldThrowOnError = false\n  protected signal?: AbortSignal\n  protected fetch: Fetch\n  protected allowEmpty: boolean\n\n  constructor(builder: PostgrestBuilder<Result>) {\n    this.method = builder.method\n    this.url = builder.url\n    this.headers = builder.headers\n    this.schema = builder.schema\n    this.body = builder.body\n    this.shouldThrowOnError = builder.shouldThrowOnError\n    this.signal = builder.signal\n    this.allowEmpty = builder.allowEmpty\n\n    if (builder.fetch) {\n      this.fetch = builder.fetch\n    } else if (typeof fetch === 'undefined') {\n      this.fetch = crossFetch\n    } else {\n      this.fetch = fetch\n    }\n  }\n\n  /**\n   * If there's an error with the query, throwOnError will reject the promise by\n   * throwing the error instead of returning it as part of a successful response.\n   *\n   * {@link https://github.com/supabase/supabase-js/issues/92}\n   */\n  throwOnError(): this {\n    this.shouldThrowOnError = true\n    return this\n  }\n\n  then<TResult1 = PostgrestResponse<Result>, TResult2 = never>(\n    onfulfilled?:\n      | ((value: PostgrestResponse<Result>) => TResult1 | PromiseLike<TResult1>)\n      | undefined\n      | null,\n    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null\n  ): PromiseLike<TResult1 | TResult2> {\n    // https://postgrest.org/en/stable/api.html#switching-schemas\n    if (this.schema === undefined) {\n      // skip\n    } else if (['GET', 'HEAD'].includes(this.method)) {\n      this.headers['Accept-Profile'] = this.schema\n    } else {\n      this.headers['Content-Profile'] = this.schema\n    }\n    if (this.method !== 'GET' && this.method !== 'HEAD') {\n      this.headers['Content-Type'] = 'application/json'\n    }\n\n    // NOTE: Invoke w/o `this` to avoid illegal invocation error.\n    // https://github.com/supabase/postgrest-js/pull/247\n    const _fetch = this.fetch\n    let res = _fetch(this.url.toString(), {\n      method: this.method,\n      headers: this.headers,\n      body: JSON.stringify(this.body),\n      signal: this.signal,\n    }).then(async (res) => {\n      let error = null\n      let data = null\n      let count: number | null = null\n      let status = res.status\n      let statusText = res.statusText\n\n      if (res.ok) {\n        if (this.method !== 'HEAD') {\n          const body = await res.text()\n          if (body === '') {\n            // Prefer: return=minimal\n          } else if (this.headers['Accept'] === 'text/csv') {\n            data = body\n          } else if (\n            this.headers['Accept'] &&\n            this.headers['Accept'].includes('application/vnd.pgrst.plan+text')\n          ) {\n            data = body\n          } else {\n            data = JSON.parse(body)\n          }\n        }\n\n        const countHeader = this.headers['Prefer']?.match(/count=(exact|planned|estimated)/)\n        const contentRange = res.headers.get('content-range')?.split('/')\n        if (countHeader && contentRange && contentRange.length > 1) {\n          count = parseInt(contentRange[1])\n        }\n      } else {\n        const body = await res.text()\n\n        try {\n          error = JSON.parse(body)\n        } catch {\n          error = {\n            message: body,\n          }\n        }\n\n        if (error && this.allowEmpty && error?.details?.includes('Results contain 0 rows')) {\n          error = null\n          status = 200\n          statusText = 'OK'\n        }\n\n        if (error && this.shouldThrowOnError) {\n          throw error\n        }\n      }\n\n      const postgrestResponse = {\n        error,\n        data,\n        count,\n        status,\n        statusText,\n      }\n\n      return postgrestResponse\n    })\n    if (!this.shouldThrowOnError) {\n      res = res.catch((fetchError) => ({\n        error: {\n          message: `FetchError: ${fetchError.message}`,\n          details: '',\n          hint: '',\n          code: fetchError.code || '',\n        },\n        data: null,\n        count: null,\n        status: 0,\n        statusText: '',\n      }))\n    }\n\n    return res.then(onfulfilled, onrejected)\n  }\n}\n","import PostgrestTransformBuilder from './PostgrestTransformBuilder'\nimport { GenericSchema } from './types'\n\ntype FilterOperator =\n  | 'eq'\n  | 'neq'\n  | 'gt'\n  | 'gte'\n  | 'lt'\n  | 'lte'\n  | 'like'\n  | 'ilike'\n  | 'is'\n  | 'in'\n  | 'cs'\n  | 'cd'\n  | 'sl'\n  | 'sr'\n  | 'nxl'\n  | 'nxr'\n  | 'adj'\n  | 'ov'\n  | 'fts'\n  | 'plfts'\n  | 'phfts'\n  | 'wfts'\n\nexport default class PostgrestFilterBuilder<\n  Schema extends GenericSchema,\n  Row extends Record<string, unknown>,\n  Result\n> extends PostgrestTransformBuilder<Schema, Row, Result> {\n  /**\n   * Match only rows where `column` is equal to `value`.\n   *\n   * To check if the value of `column` is NULL, you should use `.is()` instead.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  eq<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  eq(column: string, value: unknown): this\n  eq(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `eq.${value}`)\n    return this\n  }\n\n  /**\n   * Match only rows where `column` is not equal to `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  neq<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  neq(column: string, value: unknown): this\n  neq(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `neq.${value}`)\n    return this\n  }\n\n  /**\n   * Match only rows where `column` is greater than `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  gt<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  gt(column: string, value: unknown): this\n  gt(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `gt.${value}`)\n    return this\n  }\n\n  /**\n   * Match only rows where `column` is greater than or equal to `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  gte<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  gte(column: string, value: unknown): this\n  gte(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `gte.${value}`)\n    return this\n  }\n\n  /**\n   * Match only rows where `column` is less than `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  lt<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  lt(column: string, value: unknown): this\n  lt(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `lt.${value}`)\n    return this\n  }\n\n  /**\n   * Match only rows where `column` is less than or equal to `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  lte<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  lte(column: string, value: unknown): this\n  lte(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `lte.${value}`)\n    return this\n  }\n\n  /**\n   * Match only rows where `column` matches `pattern` case-sensitively.\n   *\n   * @param column - The column to filter on\n   * @param pattern - The pattern to match with\n   */\n  like<ColumnName extends string & keyof Row>(column: ColumnName, pattern: string): this\n  like(column: string, pattern: string): this\n  like(column: string, pattern: string): this {\n    this.url.searchParams.append(column, `like.${pattern}`)\n    return this\n  }\n\n  /**\n   * Match only rows where `column` matches `pattern` case-insensitively.\n   *\n   * @param column - The column to filter on\n   * @param pattern - The pattern to match with\n   */\n  ilike<ColumnName extends string & keyof Row>(column: ColumnName, pattern: string): this\n  ilike(column: string, pattern: string): this\n  ilike(column: string, pattern: string): this {\n    this.url.searchParams.append(column, `ilike.${pattern}`)\n    return this\n  }\n\n  /**\n   * Match only rows where `column` IS `value`.\n   *\n   * For non-boolean columns, this is only relevant for checking if the value of\n   * `column` is NULL by setting `value` to `null`.\n   *\n   * For boolean columns, you can also set `value` to `true` or `false` and it\n   * will behave the same way as `.eq()`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  is<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    value: Row[ColumnName] & (boolean | null)\n  ): this\n  is(column: string, value: boolean | null): this\n  is(column: string, value: boolean | null): this {\n    this.url.searchParams.append(column, `is.${value}`)\n    return this\n  }\n\n  /**\n   * Match only rows where `column` is included in the `values` array.\n   *\n   * @param column - The column to filter on\n   * @param values - The values array to filter with\n   */\n  in<ColumnName extends string & keyof Row>(column: ColumnName, values: Row[ColumnName][]): this\n  in(column: string, values: unknown[]): this\n  in(column: string, values: unknown[]): this {\n    const cleanedValues = values\n      .map((s) => {\n        // handle postgrest reserved characters\n        // https://postgrest.org/en/v7.0.0/api.html#reserved-characters\n        if (typeof s === 'string' && new RegExp('[,()]').test(s)) return `\"${s}\"`\n        else return `${s}`\n      })\n      .join(',')\n    this.url.searchParams.append(column, `in.(${cleanedValues})`)\n    return this\n  }\n\n  /**\n   * Only relevant for jsonb, array, and range columns. Match only rows where\n   * `column` contains every element appearing in `value`.\n   *\n   * @param column - The jsonb, array, or range column to filter on\n   * @param value - The jsonb, array, or range value to filter with\n   */\n  contains<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    value: string | Row[ColumnName][] | Record<string, unknown>\n  ): this\n  contains(column: string, value: string | unknown[] | Record<string, unknown>): this\n  contains(column: string, value: string | unknown[] | Record<string, unknown>): this {\n    if (typeof value === 'string') {\n      // range types can be inclusive '[', ']' or exclusive '(', ')' so just\n      // keep it simple and accept a string\n      this.url.searchParams.append(column, `cs.${value}`)\n    } else if (Array.isArray(value)) {\n      // array\n      this.url.searchParams.append(column, `cs.{${value.join(',')}}`)\n    } else {\n      // json\n      this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`)\n    }\n    return this\n  }\n\n  /**\n   * Only relevant for jsonb, array, and range columns. Match only rows where\n   * every element appearing in `column` is contained by `value`.\n   *\n   * @param column - The jsonb, array, or range column to filter on\n   * @param value - The jsonb, array, or range value to filter with\n   */\n  containedBy<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    value: string | Row[ColumnName][] | Record<string, unknown>\n  ): this\n  containedBy(column: string, value: string | unknown[] | Record<string, unknown>): this\n  containedBy(column: string, value: string | unknown[] | Record<string, unknown>): this {\n    if (typeof value === 'string') {\n      // range\n      this.url.searchParams.append(column, `cd.${value}`)\n    } else if (Array.isArray(value)) {\n      // array\n      this.url.searchParams.append(column, `cd.{${value.join(',')}}`)\n    } else {\n      // json\n      this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`)\n    }\n    return this\n  }\n\n  /**\n   * Only relevant for range columns. Match only rows where every element in\n   * `column` is greater than any element in `range`.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeGt<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeGt(column: string, range: string): this\n  rangeGt(column: string, range: string): this {\n    this.url.searchParams.append(column, `sr.${range}`)\n    return this\n  }\n\n  /**\n   * Only relevant for range columns. Match only rows where every element in\n   * `column` is either contained in `range` or greater than any element in\n   * `range`.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeGte<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeGte(column: string, range: string): this\n  rangeGte(column: string, range: string): this {\n    this.url.searchParams.append(column, `nxl.${range}`)\n    return this\n  }\n\n  /**\n   * Only relevant for range columns. Match only rows where every element in\n   * `column` is less than any element in `range`.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeLt<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeLt(column: string, range: string): this\n  rangeLt(column: string, range: string): this {\n    this.url.searchParams.append(column, `sl.${range}`)\n    return this\n  }\n\n  /**\n   * Only relevant for range columns. Match only rows where every element in\n   * `column` is either contained in `range` or less than any element in\n   * `range`.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeLte<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeLte(column: string, range: string): this\n  rangeLte(column: string, range: string): this {\n    this.url.searchParams.append(column, `nxr.${range}`)\n    return this\n  }\n\n  /**\n   * Only relevant for range columns. Match only rows where `column` is\n   * mutually exclusive to `range` and there can be no element between the two\n   * ranges.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeAdjacent<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeAdjacent(column: string, range: string): this\n  rangeAdjacent(column: string, range: string): this {\n    this.url.searchParams.append(column, `adj.${range}`)\n    return this\n  }\n\n  /**\n   * Only relevant for array and range columns. Match only rows where\n   * `column` and `value` have an element in common.\n   *\n   * @param column - The array or range column to filter on\n   * @param value - The array or range value to filter with\n   */\n  overlaps<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    value: string | Row[ColumnName][]\n  ): this\n  overlaps(column: string, value: string | unknown[]): this\n  overlaps(column: string, value: string | unknown[]): this {\n    if (typeof value === 'string') {\n      // range\n      this.url.searchParams.append(column, `ov.${value}`)\n    } else {\n      // array\n      this.url.searchParams.append(column, `ov.{${value.join(',')}}`)\n    }\n    return this\n  }\n\n  /**\n   * Only relevant for text and tsvector columns. Match only rows where\n   * `column` matches the query string in `query`.\n   *\n   * @param column - The text or tsvector column to filter on\n   * @param query - The query text to match with\n   * @param options - Named parameters\n   * @param options.config - The text search configuration to use\n   * @param options.type - Change how the `query` text is interpreted\n   */\n  textSearch<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    query: string,\n    options?: { config?: string; type?: 'plain' | 'phrase' | 'websearch' }\n  ): this\n  textSearch(\n    column: string,\n    query: string,\n    options?: { config?: string; type?: 'plain' | 'phrase' | 'websearch' }\n  ): this\n  textSearch(\n    column: string,\n    query: string,\n    { config, type }: { config?: string; type?: 'plain' | 'phrase' | 'websearch' } = {}\n  ): this {\n    let typePart = ''\n    if (type === 'plain') {\n      typePart = 'pl'\n    } else if (type === 'phrase') {\n      typePart = 'ph'\n    } else if (type === 'websearch') {\n      typePart = 'w'\n    }\n    const configPart = config === undefined ? '' : `(${config})`\n    this.url.searchParams.append(column, `${typePart}fts${configPart}.${query}`)\n    return this\n  }\n\n  /**\n   * Match only rows where each column in `query` keys is equal to its\n   * associated value. Shorthand for multiple `.eq()`s.\n   *\n   * @param query - The object to filter with, with column names as keys mapped\n   * to their filter values\n   */\n  match<ColumnName extends string & keyof Row>(query: Record<ColumnName, Row[ColumnName]>): this\n  match(query: Record<string, unknown>): this\n  match(query: Record<string, unknown>): this {\n    Object.entries(query).forEach(([column, value]) => {\n      this.url.searchParams.append(column, `eq.${value}`)\n    })\n    return this\n  }\n\n  /**\n   * Match only rows which doesn't satisfy the filter.\n   *\n   * Unlike most filters, `opearator` and `value` are used as-is and need to\n   * follow [PostgREST\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n   * to make sure they are properly sanitized.\n   *\n   * @param column - The column to filter on\n   * @param operator - The operator to be negated to filter with, following\n   * PostgREST syntax\n   * @param value - The value to filter with, following PostgREST syntax\n   */\n  not<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    operator: FilterOperator,\n    value: Row[ColumnName]\n  ): this\n  not(column: string, operator: string, value: unknown): this\n  not(column: string, operator: string, value: unknown): this {\n    this.url.searchParams.append(column, `not.${operator}.${value}`)\n    return this\n  }\n\n  /**\n   * Match only rows which satisfy at least one of the filters.\n   *\n   * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n   * to make sure it's properly sanitized.\n   *\n   * It's currently not possible to do an `.or()` filter across multiple tables.\n   *\n   * @param filters - The filters to use, following PostgREST syntax\n   * @param foreignTable - Set this to filter on foreign tables instead of the\n   * current table\n   */\n  or(filters: string, { foreignTable }: { foreignTable?: string } = {}): this {\n    const key = foreignTable ? `${foreignTable}.or` : 'or'\n    this.url.searchParams.append(key, `(${filters})`)\n    return this\n  }\n\n  /**\n   * Match only rows which satisfy the filter. This is an escape hatch - you\n   * should use the specific filter methods wherever possible.\n   *\n   * Unlike most filters, `opearator` and `value` are used as-is and need to\n   * follow [PostgREST\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n   * to make sure they are properly sanitized.\n   *\n   * @param column - The column to filter on\n   * @param operator - The operator to filter with, following PostgREST syntax\n   * @param value - The value to filter with, following PostgREST syntax\n   */\n  filter<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    operator: `${'' | 'not.'}${FilterOperator}`,\n    value: unknown\n  ): this\n  filter(column: string, operator: string, value: unknown): this\n  filter(column: string, operator: string, value: unknown): this {\n    this.url.searchParams.append(column, `${operator}.${value}`)\n    return this\n  }\n}\n","import PostgrestBuilder from './PostgrestBuilder'\nimport PostgrestFilterBuilder from './PostgrestFilterBuilder'\nimport { GetResult } from './select-query-parser'\nimport { Fetch, GenericSchema, GenericTable, GenericView } from './types'\n\nexport default class PostgrestQueryBuilder<\n  Schema extends GenericSchema,\n  Relation extends GenericTable | GenericView\n> {\n  url: URL\n  headers: Record<string, string>\n  schema?: string\n  signal?: AbortSignal\n  fetch?: Fetch\n\n  constructor(\n    url: URL,\n    {\n      headers = {},\n      schema,\n      fetch,\n    }: {\n      headers?: Record<string, string>\n      schema?: string\n      fetch?: Fetch\n    }\n  ) {\n    this.url = url\n    this.headers = headers\n    this.schema = schema\n    this.fetch = fetch\n  }\n\n  /**\n   * Perform a SELECT query on the table or view.\n   *\n   * @param columns - The columns to retrieve, separated by commas\n   *\n   * @param options - Named parameters\n   *\n   * @param options.head - When set to `true`, `data` will not be returned.\n   * Useful if you only need the count.\n   *\n   * @param options.count - Count algorithm to use to count rows in the table or view.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  select<Query extends string = '*', Result = GetResult<Schema, Relation['Row'], Query>>(\n    columns?: Query,\n    {\n      head = false,\n      count,\n    }: {\n      head?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n    } = {}\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], Result> {\n    const method = head ? 'HEAD' : 'GET'\n    // Remove whitespaces except when quoted\n    let quoted = false\n    const cleanedColumns = (columns ?? '*')\n      .split('')\n      .map((c) => {\n        if (/\\s/.test(c) && !quoted) {\n          return ''\n        }\n        if (c === '\"') {\n          quoted = !quoted\n        }\n        return c\n      })\n      .join('')\n    this.url.searchParams.set('select', cleanedColumns)\n    if (count) {\n      this.headers['Prefer'] = `count=${count}`\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      fetch: this.fetch,\n      allowEmpty: false,\n    } as unknown as PostgrestBuilder<Result>)\n  }\n\n  /**\n   * Perform an INSERT into the table or view.\n   *\n   * By default, inserted rows are not returned. To return it, chain the call\n   * with `.select()`.\n   *\n   * @param values - The values to insert. Pass an object to insert a single row\n   * or an array to insert multiple rows.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count inserted rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  insert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row | Row[],\n    {\n      count,\n    }: {\n      count?: 'exact' | 'planned' | 'estimated'\n    } = {}\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], undefined> {\n    const method = 'POST'\n\n    const prefersHeaders = []\n    const body = values\n    if (count) {\n      prefersHeaders.push(`count=${count}`)\n    }\n    if (this.headers['Prefer']) {\n      prefersHeaders.unshift(this.headers['Prefer'])\n    }\n    this.headers['Prefer'] = prefersHeaders.join(',')\n\n    if (Array.isArray(values)) {\n      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), [] as string[])\n      if (columns.length > 0) {\n        const uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`)\n        this.url.searchParams.set('columns', uniqueColumns.join(','))\n      }\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body,\n      fetch: this.fetch,\n      allowEmpty: false,\n    } as unknown as PostgrestBuilder<undefined>)\n  }\n\n  /**\n   * Perform an UPSERT on the table or view. Depending on the column(s) passed\n   * to `onConflict`, `.upsert()` allows you to perform the equivalent of\n   * `.insert()` if a row with the corresponding `onConflict` columns doesn't\n   * exist, or if it does exist, perform an alternative action depending on\n   * `ignoreDuplicates`.\n   *\n   * By default, upserted rows are not returned. To return it, chain the call\n   * with `.select()`.\n   *\n   * @param values - The values to upsert with. Pass an object to upsert a\n   * single row or an array to upsert multiple rows.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how\n   * duplicate rows are determined. Two rows are duplicates if all the\n   * `onConflict` columns are equal.\n   *\n   * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If\n   * `false`, duplicate rows are merged with existing rows.\n   *\n   * @param options.count - Count algorithm to use to count upserted rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  upsert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row | Row[],\n    {\n      onConflict,\n      ignoreDuplicates = false,\n      count,\n    }: {\n      onConflict?: string\n      ignoreDuplicates?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n    } = {}\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], undefined> {\n    const method = 'POST'\n\n    const prefersHeaders = [`resolution=${ignoreDuplicates ? 'ignore' : 'merge'}-duplicates`]\n\n    if (onConflict !== undefined) this.url.searchParams.set('on_conflict', onConflict)\n    const body = values\n    if (count) {\n      prefersHeaders.push(`count=${count}`)\n    }\n    if (this.headers['Prefer']) {\n      prefersHeaders.unshift(this.headers['Prefer'])\n    }\n    this.headers['Prefer'] = prefersHeaders.join(',')\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body,\n      fetch: this.fetch,\n      allowEmpty: false,\n    } as unknown as PostgrestBuilder<undefined>)\n  }\n\n  /**\n   * Perform an UPDATE on the table or view.\n   *\n   * By default, updated rows are not returned. To return it, chain the call\n   * with `.select()` after filters.\n   *\n   * @param values - The values to update with\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count updated rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  update<Row extends Relation extends { Update: unknown } ? Relation['Update'] : never>(\n    values: Row,\n    {\n      count,\n    }: {\n      count?: 'exact' | 'planned' | 'estimated'\n    } = {}\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], undefined> {\n    const method = 'PATCH'\n    const prefersHeaders = []\n    const body = values\n    if (count) {\n      prefersHeaders.push(`count=${count}`)\n    }\n    if (this.headers['Prefer']) {\n      prefersHeaders.unshift(this.headers['Prefer'])\n    }\n    this.headers['Prefer'] = prefersHeaders.join(',')\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body,\n      fetch: this.fetch,\n      allowEmpty: false,\n    } as unknown as PostgrestBuilder<undefined>)\n  }\n\n  /**\n   * Perform a DELETE on the table or view.\n   *\n   * By default, deleted rows are not returned. To return it, chain the call\n   * with `.select()` after filters.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count deleted rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  delete({\n    count,\n  }: {\n    count?: 'exact' | 'planned' | 'estimated'\n  } = {}): PostgrestFilterBuilder<Schema, Relation['Row'], undefined> {\n    const method = 'DELETE'\n    const prefersHeaders = []\n    if (count) {\n      prefersHeaders.push(`count=${count}`)\n    }\n    if (this.headers['Prefer']) {\n      prefersHeaders.unshift(this.headers['Prefer'])\n    }\n    this.headers['Prefer'] = prefersHeaders.join(',')\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      fetch: this.fetch,\n      allowEmpty: false,\n    } as unknown as PostgrestBuilder<undefined>)\n  }\n}\n","import { version } from './version'\nexport const DEFAULT_HEADERS = { 'X-Client-Info': `postgrest-js/${version}` }\n","export const version = '1.1.0'\n","import PostgrestQueryBuilder from './PostgrestQueryBuilder'\nimport PostgrestFilterBuilder from './PostgrestFilterBuilder'\nimport PostgrestBuilder from './PostgrestBuilder'\nimport { DEFAULT_HEADERS } from './constants'\nimport { Fetch, GenericSchema } from './types'\n\n/**\n * PostgREST client.\n *\n * @typeParam Database - Types for the schema from the [type\n * generator](https://supabase.com/docs/reference/javascript/next/typescript-support)\n *\n * @typeParam SchemaName - Postgres schema to switch to. Must be a string\n * literal, the same one passed to the constructor. If the schema is not\n * `\"public\"`, this must be supplied manually.\n */\nexport default class PostgrestClient<\n  Database = any,\n  SchemaName extends string & keyof Database = 'public' extends keyof Database\n    ? 'public'\n    : string & keyof Database,\n  Schema extends GenericSchema = Database[SchemaName] extends GenericSchema\n    ? Database[SchemaName]\n    : any\n> {\n  url: string\n  headers: Record<string, string>\n  schema?: SchemaName\n  fetch?: Fetch\n\n  // TODO: Add back shouldThrowOnError once we figure out the typings\n  /**\n   * Creates a PostgREST client.\n   *\n   * @param url - URL of the PostgREST endpoint\n   * @param options - Named parameters\n   * @param options.headers - Custom headers\n   * @param options.schema - Postgres schema to switch to\n   * @param options.fetch - Custom fetch\n   */\n  constructor(\n    url: string,\n    {\n      headers = {},\n      schema,\n      fetch,\n    }: {\n      headers?: Record<string, string>\n      schema?: SchemaName\n      fetch?: Fetch\n    } = {}\n  ) {\n    this.url = url\n    this.headers = { ...DEFAULT_HEADERS, ...headers }\n    this.schema = schema\n    this.fetch = fetch\n  }\n\n  /**\n   * Perform a query on a table or a view.\n   *\n   * @param relation - The table or view name to query\n   */\n  from<\n    TableName extends string & keyof Schema['Tables'],\n    Table extends Schema['Tables'][TableName]\n  >(relation: TableName): PostgrestQueryBuilder<Schema, Table>\n  from<ViewName extends string & keyof Schema['Views'], View extends Schema['Views'][ViewName]>(\n    relation: ViewName\n  ): PostgrestQueryBuilder<Schema, View>\n  from(relation: string): PostgrestQueryBuilder<Schema, any>\n  from(relation: string): PostgrestQueryBuilder<Schema, any> {\n    const url = new URL(`${this.url}/${relation}`)\n    return new PostgrestQueryBuilder<Schema, any>(url, {\n      headers: { ...this.headers },\n      schema: this.schema,\n      fetch: this.fetch,\n    })\n  }\n\n  /**\n   * Perform a function call.\n   *\n   * @param fn - The function name to call\n   * @param args - The arguments to pass to the function call\n   * @param options - Named parameters\n   * @param options.head - When set to `true`, `data` will not be returned.\n   * Useful if you only need the count.\n   * @param options.count - Count algorithm to use to count rows returned by the\n   * function. Only applicable for [set-returning\n   * functions](https://www.postgresql.org/docs/current/functions-srf.html).\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  rpc<\n    FunctionName extends string & keyof Schema['Functions'],\n    Function_ extends Schema['Functions'][FunctionName]\n  >(\n    fn: FunctionName,\n    args: Function_['Args'] = {},\n    {\n      head = false,\n      count,\n    }: {\n      head?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n    } = {}\n  ): PostgrestFilterBuilder<\n    Schema,\n    Function_['Returns'] extends any[]\n      ? Function_['Returns'][number] extends Record<string, unknown>\n        ? Function_['Returns'][number]\n        : never\n      : never,\n    Function_['Returns']\n  > {\n    let method: 'HEAD' | 'POST'\n    const url = new URL(`${this.url}/rpc/${fn}`)\n    let body: unknown | undefined\n    if (head) {\n      method = 'HEAD'\n      Object.entries(args).forEach(([name, value]) => {\n        url.searchParams.append(name, `${value}`)\n      })\n    } else {\n      method = 'POST'\n      body = args\n    }\n\n    const headers = { ...this.headers }\n    if (count) {\n      headers['Prefer'] = `count=${count}`\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url,\n      headers,\n      schema: this.schema,\n      body,\n      fetch: this.fetch,\n      allowEmpty: false,\n    } as unknown as PostgrestBuilder<Function_['Returns']>)\n  }\n}\n","export const version = '2.1.0'\n","/*\n  This file draws heavily from https://github.com/phoenixframework/phoenix/blob/d344ec0a732ab4ee204215b31de69cf4be72e3bf/assets/js/phoenix/presence.js\n  License: https://github.com/phoenixframework/phoenix/blob/d344ec0a732ab4ee204215b31de69cf4be72e3bf/LICENSE.md\n*/\n\nimport {\n  PresenceOpts,\n  PresenceOnJoinCallback,\n  PresenceOnLeaveCallback,\n} from 'phoenix'\nimport RealtimeChannel from './RealtimeChannel'\n\ntype Presence = {\n  presence_ref: string\n  [key: string]: any\n}\n\nexport type RealtimePresenceState = { [key: string]: Presence[] }\n\nexport type RealtimePresenceJoinPayload = {\n  event: `${REALTIME_PRESENCE_LISTEN_EVENTS.JOIN}`\n  key: string\n  currentPresences: Presence[]\n  newPresences: Presence[]\n}\n\nexport type RealtimePresenceLeavePayload = {\n  event: `${REALTIME_PRESENCE_LISTEN_EVENTS.LEAVE}`\n  key: string\n  currentPresences: Presence[]\n  leftPresences: Presence[]\n}\n\nexport enum REALTIME_PRESENCE_LISTEN_EVENTS {\n  SYNC = 'sync',\n  JOIN = 'join',\n  LEAVE = 'leave',\n}\n\ntype PresenceDiff = {\n  joins: RealtimePresenceState\n  leaves: RealtimePresenceState\n}\n\ntype RawPresenceState = {\n  [key: string]: {\n    metas: {\n      phx_ref?: string\n      phx_ref_prev?: string\n      [key: string]: any\n    }[]\n  }\n}\n\ntype RawPresenceDiff = {\n  joins: RawPresenceState\n  leaves: RawPresenceState\n}\n\ntype PresenceChooser<T> = (key: string, presences: Presence[]) => T\n\nexport default class RealtimePresence {\n  state: RealtimePresenceState = {}\n  pendingDiffs: RawPresenceDiff[] = []\n  joinRef: string | null = null\n  caller: {\n    onJoin: PresenceOnJoinCallback\n    onLeave: PresenceOnLeaveCallback\n    onSync: () => void\n  } = {\n    onJoin: () => {},\n    onLeave: () => {},\n    onSync: () => {},\n  }\n\n  /**\n   * Initializes the Presence.\n   *\n   * @param channel - The RealtimeChannel\n   * @param opts - The options,\n   *        for example `{events: {state: 'state', diff: 'diff'}}`\n   */\n  constructor(public channel: RealtimeChannel, opts?: PresenceOpts) {\n    const events = opts?.events || {\n      state: 'presence_state',\n      diff: 'presence_diff',\n    }\n\n    this.channel._on(events.state, {}, (newState: RawPresenceState) => {\n      const { onJoin, onLeave, onSync } = this.caller\n\n      this.joinRef = this.channel._joinRef()\n\n      this.state = RealtimePresence.syncState(\n        this.state,\n        newState,\n        onJoin,\n        onLeave\n      )\n\n      this.pendingDiffs.forEach((diff) => {\n        this.state = RealtimePresence.syncDiff(\n          this.state,\n          diff,\n          onJoin,\n          onLeave\n        )\n      })\n\n      this.pendingDiffs = []\n\n      onSync()\n    })\n\n    this.channel._on(events.diff, {}, (diff: RawPresenceDiff) => {\n      const { onJoin, onLeave, onSync } = this.caller\n\n      if (this.inPendingSyncState()) {\n        this.pendingDiffs.push(diff)\n      } else {\n        this.state = RealtimePresence.syncDiff(\n          this.state,\n          diff,\n          onJoin,\n          onLeave\n        )\n\n        onSync()\n      }\n    })\n\n    this.onJoin((key, currentPresences, newPresences) => {\n      this.channel._trigger('presence', {\n        event: 'join',\n        key,\n        currentPresences,\n        newPresences,\n      })\n    })\n\n    this.onLeave((key, currentPresences, leftPresences) => {\n      this.channel._trigger('presence', {\n        event: 'leave',\n        key,\n        currentPresences,\n        leftPresences,\n      })\n    })\n\n    this.onSync(() => {\n      this.channel._trigger('presence', { event: 'sync' })\n    })\n  }\n\n  /**\n   * Used to sync the list of presences on the server with the\n   * client's state.\n   *\n   * An optional `onJoin` and `onLeave` callback can be provided to\n   * react to changes in the client's local presences across\n   * disconnects and reconnects with the server.\n   *\n   * @internal\n   */\n  private static syncState(\n    currentState: RealtimePresenceState,\n    newState: RawPresenceState | RealtimePresenceState,\n    onJoin: PresenceOnJoinCallback,\n    onLeave: PresenceOnLeaveCallback\n  ): RealtimePresenceState {\n    const state = this.cloneDeep(currentState)\n    const transformedState = this.transformState(newState)\n    const joins: RealtimePresenceState = {}\n    const leaves: RealtimePresenceState = {}\n\n    this.map(state, (key: string, presences: Presence[]) => {\n      if (!transformedState[key]) {\n        leaves[key] = presences\n      }\n    })\n\n    this.map(transformedState, (key, newPresences: Presence[]) => {\n      const currentPresences: Presence[] = state[key]\n\n      if (currentPresences) {\n        const newPresenceRefs = newPresences.map(\n          (m: Presence) => m.presence_ref\n        )\n        const curPresenceRefs = currentPresences.map(\n          (m: Presence) => m.presence_ref\n        )\n        const joinedPresences: Presence[] = newPresences.filter(\n          (m: Presence) => curPresenceRefs.indexOf(m.presence_ref) < 0\n        )\n        const leftPresences: Presence[] = currentPresences.filter(\n          (m: Presence) => newPresenceRefs.indexOf(m.presence_ref) < 0\n        )\n\n        if (joinedPresences.length > 0) {\n          joins[key] = joinedPresences\n        }\n\n        if (leftPresences.length > 0) {\n          leaves[key] = leftPresences\n        }\n      } else {\n        joins[key] = newPresences\n      }\n    })\n\n    return this.syncDiff(state, { joins, leaves }, onJoin, onLeave)\n  }\n\n  /**\n   * Used to sync a diff of presence join and leave events from the\n   * server, as they happen.\n   *\n   * Like `syncState`, `syncDiff` accepts optional `onJoin` and\n   * `onLeave` callbacks to react to a user joining or leaving from a\n   * device.\n   *\n   * @internal\n   */\n  private static syncDiff(\n    state: RealtimePresenceState,\n    diff: RawPresenceDiff | PresenceDiff,\n    onJoin: PresenceOnJoinCallback,\n    onLeave: PresenceOnLeaveCallback\n  ): RealtimePresenceState {\n    const { joins, leaves } = {\n      joins: this.transformState(diff.joins),\n      leaves: this.transformState(diff.leaves),\n    }\n\n    if (!onJoin) {\n      onJoin = () => {}\n    }\n\n    if (!onLeave) {\n      onLeave = () => {}\n    }\n\n    this.map(joins, (key, newPresences: Presence[]) => {\n      const currentPresences: Presence[] = state[key] ?? []\n      state[key] = this.cloneDeep(newPresences)\n\n      if (currentPresences.length > 0) {\n        const joinedPresenceRefs = state[key].map(\n          (m: Presence) => m.presence_ref\n        )\n        const curPresences: Presence[] = currentPresences.filter(\n          (m: Presence) => joinedPresenceRefs.indexOf(m.presence_ref) < 0\n        )\n\n        state[key].unshift(...curPresences)\n      }\n\n      onJoin(key, currentPresences, newPresences)\n    })\n\n    this.map(leaves, (key, leftPresences: Presence[]) => {\n      let currentPresences: Presence[] = state[key]\n\n      if (!currentPresences) return\n\n      const presenceRefsToRemove = leftPresences.map(\n        (m: Presence) => m.presence_ref\n      )\n      currentPresences = currentPresences.filter(\n        (m: Presence) => presenceRefsToRemove.indexOf(m.presence_ref) < 0\n      )\n\n      state[key] = currentPresences\n\n      onLeave(key, currentPresences, leftPresences)\n\n      if (currentPresences.length === 0) delete state[key]\n    })\n\n    return state\n  }\n\n  /** @internal */\n  private static map<T = any>(\n    obj: RealtimePresenceState,\n    func: PresenceChooser<T>\n  ): T[] {\n    return Object.getOwnPropertyNames(obj).map((key) => func(key, obj[key]))\n  }\n\n  /**\n   * Remove 'metas' key\n   * Change 'phx_ref' to 'presence_ref'\n   * Remove 'phx_ref' and 'phx_ref_prev'\n   *\n   * @example\n   * // returns {\n   *  abc123: [\n   *    { presence_ref: '2', user_id: 1 },\n   *    { presence_ref: '3', user_id: 2 }\n   *  ]\n   * }\n   * RealtimePresence.transformState({\n   *  abc123: {\n   *    metas: [\n   *      { phx_ref: '2', phx_ref_prev: '1' user_id: 1 },\n   *      { phx_ref: '3', user_id: 2 }\n   *    ]\n   *  }\n   * })\n   *\n   * @internal\n   */\n  private static transformState(\n    state: RawPresenceState | RealtimePresenceState\n  ): RealtimePresenceState {\n    state = this.cloneDeep(state)\n\n    return Object.getOwnPropertyNames(state).reduce((newState, key) => {\n      const presences = state[key]\n\n      if ('metas' in presences) {\n        newState[key] = presences.metas.map((presence) => {\n          presence['presence_ref'] = presence['phx_ref']\n\n          delete presence['phx_ref']\n          delete presence['phx_ref_prev']\n\n          return presence\n        }) as Presence[]\n      } else {\n        newState[key] = presences\n      }\n\n      return newState\n    }, {} as RealtimePresenceState)\n  }\n\n  /** @internal */\n  private static cloneDeep(obj: { [key: string]: any }) {\n    return JSON.parse(JSON.stringify(obj))\n  }\n\n  /** @internal */\n  private onJoin(callback: PresenceOnJoinCallback): void {\n    this.caller.onJoin = callback\n  }\n\n  /** @internal */\n  private onLeave(callback: PresenceOnLeaveCallback): void {\n    this.caller.onLeave = callback\n  }\n\n  /** @internal */\n  private onSync(callback: () => void): void {\n    this.caller.onSync = callback\n  }\n\n  /** @internal */\n  private inPendingSyncState(): boolean {\n    return !this.joinRef || this.joinRef !== this.channel._joinRef()\n  }\n}\n","/**\n * Creates a timer that accepts a `timerCalc` function to perform calculated timeout retries, such as exponential backoff.\n *\n * @example\n *    let reconnectTimer = new Timer(() => this.connect(), function(tries){\n *      return [1000, 5000, 10000][tries - 1] || 10000\n *    })\n *    reconnectTimer.scheduleTimeout() // fires after 1000\n *    reconnectTimer.scheduleTimeout() // fires after 5000\n *    reconnectTimer.reset()\n *    reconnectTimer.scheduleTimeout() // fires after 1000\n */\nexport default class Timer {\n  timer: number | undefined = undefined\n  tries: number = 0\n\n  constructor(public callback: Function, public timerCalc: Function) {\n    this.callback = callback\n    this.timerCalc = timerCalc\n  }\n\n  reset() {\n    this.tries = 0\n    clearTimeout(this.timer)\n  }\n\n  // Cancels any previous scheduleTimeout and schedules callback\n  scheduleTimeout() {\n    clearTimeout(this.timer)\n\n    this.timer = <any>setTimeout(() => {\n      this.tries = this.tries + 1\n      this.callback()\n    }, this.timerCalc(this.tries + 1))\n  }\n}\n","// This file draws heavily from https://github.com/phoenixframework/phoenix/commit/cf098e9cf7a44ee6479d31d911a97d3c7430c6fe\n// License: https://github.com/phoenixframework/phoenix/blob/master/LICENSE.md\n\nexport default class Serializer {\n  HEADER_LENGTH = 1\n\n  decode(rawPayload: ArrayBuffer | string, callback: Function) {\n    if (rawPayload.constructor === ArrayBuffer) {\n      return callback(this._binaryDecode(rawPayload))\n    }\n\n    if (typeof rawPayload === 'string') {\n      return callback(JSON.parse(rawPayload))\n    }\n\n    return callback({})\n  }\n\n  private _binaryDecode(buffer: ArrayBuffer) {\n    const view = new DataView(buffer)\n    const decoder = new TextDecoder()\n\n    return this._decodeBroadcast(buffer, view, decoder)\n  }\n\n  private _decodeBroadcast(\n    buffer: ArrayBuffer,\n    view: DataView,\n    decoder: TextDecoder\n  ): {\n    ref: null\n    topic: string\n    event: string\n    payload: { [key: string]: any }\n  } {\n    const topicSize = view.getUint8(1)\n    const eventSize = view.getUint8(2)\n    let offset = this.HEADER_LENGTH + 2\n    const topic = decoder.decode(buffer.slice(offset, offset + topicSize))\n    offset = offset + topicSize\n    const event = decoder.decode(buffer.slice(offset, offset + eventSize))\n    offset = offset + eventSize\n    const data = JSON.parse(\n      decoder.decode(buffer.slice(offset, buffer.byteLength))\n    )\n\n    return { ref: null, topic: topic, event: event, payload: data }\n  }\n}\n","import { DEFAULT_TIMEOUT } from '../lib/constants'\nimport RealtimeChannel from '../RealtimeChannel'\n\nexport default class Push {\n  sent: boolean = false\n  timeoutTimer: number | undefined = undefined\n  ref: string = ''\n  receivedResp: {\n    status: string\n    response: { [key: string]: any }\n  } | null = null\n  recHooks: {\n    status: string\n    callback: Function\n  }[] = []\n  refEvent: string | null = null\n  rateLimited: boolean = false\n\n  /**\n   * Initializes the Push\n   *\n   * @param channel The Channel\n   * @param event The event, for example `\"phx_join\"`\n   * @param payload The payload, for example `{user_id: 123}`\n   * @param timeout The push timeout in milliseconds\n   */\n  constructor(\n    public channel: RealtimeChannel,\n    public event: string,\n    public payload: { [key: string]: any } = {},\n    public timeout: number = DEFAULT_TIMEOUT\n  ) {}\n\n  resend(timeout: number) {\n    this.timeout = timeout\n    this._cancelRefEvent()\n    this.ref = ''\n    this.refEvent = null\n    this.receivedResp = null\n    this.sent = false\n    this.send()\n  }\n\n  send() {\n    if (this._hasReceived('timeout')) {\n      return\n    }\n    this.startTimeout()\n    this.sent = true\n    const status = this.channel.socket.push({\n      topic: this.channel.topic,\n      event: this.event,\n      payload: this.payload,\n      ref: this.ref,\n      join_ref: this.channel._joinRef(),\n    })\n    if (status === 'rate limited') {\n      this.rateLimited = true\n    }\n  }\n\n  updatePayload(payload: { [key: string]: any }): void {\n    this.payload = { ...this.payload, ...payload }\n  }\n\n  receive(status: string, callback: Function) {\n    if (this._hasReceived(status)) {\n      callback(this.receivedResp?.response)\n    }\n\n    this.recHooks.push({ status, callback })\n    return this\n  }\n\n  startTimeout() {\n    if (this.timeoutTimer) {\n      return\n    }\n    this.ref = this.channel.socket._makeRef()\n    this.refEvent = this.channel._replyEventName(this.ref)\n\n    const callback = (payload: any) => {\n      this._cancelRefEvent()\n      this._cancelTimeout()\n      this.receivedResp = payload\n      this._matchReceive(payload)\n    }\n\n    this.channel._on(this.refEvent, {}, callback)\n\n    this.timeoutTimer = <any>setTimeout(() => {\n      this.trigger('timeout', {})\n    }, this.timeout)\n  }\n\n  trigger(status: string, response: any) {\n    if (this.refEvent)\n      this.channel._trigger(this.refEvent, { status, response })\n  }\n\n  destroy() {\n    this._cancelRefEvent()\n    this._cancelTimeout()\n  }\n\n  private _cancelRefEvent() {\n    if (!this.refEvent) {\n      return\n    }\n\n    this.channel._off(this.refEvent, {})\n  }\n\n  private _cancelTimeout() {\n    clearTimeout(this.timeoutTimer)\n    this.timeoutTimer = undefined\n  }\n\n  private _matchReceive({\n    status,\n    response,\n  }: {\n    status: string\n    response: Function\n  }) {\n    this.recHooks\n      .filter((h) => h.status === status)\n      .forEach((h) => h.callback(response))\n  }\n\n  private _hasReceived(status: string) {\n    return this.receivedResp && this.receivedResp.status === status\n  }\n}\n","/**\n * Helpers to convert the change Payload into native JS types.\n */\n\n// Adapted from epgsql (src/epgsql_binary.erl), this module licensed under\n// 3-clause BSD found here: https://raw.githubusercontent.com/epgsql/epgsql/devel/LICENSE\n\nexport enum PostgresTypes {\n  abstime = 'abstime',\n  bool = 'bool',\n  date = 'date',\n  daterange = 'daterange',\n  float4 = 'float4',\n  float8 = 'float8',\n  int2 = 'int2',\n  int4 = 'int4',\n  int4range = 'int4range',\n  int8 = 'int8',\n  int8range = 'int8range',\n  json = 'json',\n  jsonb = 'jsonb',\n  money = 'money',\n  numeric = 'numeric',\n  oid = 'oid',\n  reltime = 'reltime',\n  text = 'text',\n  time = 'time',\n  timestamp = 'timestamp',\n  timestamptz = 'timestamptz',\n  timetz = 'timetz',\n  tsrange = 'tsrange',\n  tstzrange = 'tstzrange',\n}\n\ntype Columns = {\n  name: string // the column name. eg: \"user_id\"\n  type: string // the column type. eg: \"uuid\"\n  flags?: string[] // any special flags for the column. eg: [\"key\"]\n  type_modifier?: number // the type modifier. eg: 4294967295\n}[]\n\ntype BaseValue = null | string | number | boolean\ntype RecordValue = BaseValue | BaseValue[]\n\ntype Record = {\n  [key: string]: RecordValue\n}\n\n/**\n * Takes an array of columns and an object of string values then converts each string value\n * to its mapped type.\n *\n * @param {{name: String, type: String}[]} columns\n * @param {Object} record\n * @param {Object} options The map of various options that can be applied to the mapper\n * @param {Array} options.skipTypes The array of types that should not be converted\n *\n * @example convertChangeData([{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age:'33'}, {})\n * //=>{ first_name: 'Paul', age: 33 }\n */\nexport const convertChangeData = (\n  columns: Columns,\n  record: Record,\n  options: { skipTypes?: string[] } = {}\n): Record => {\n  const skipTypes = options.skipTypes ?? []\n\n  return Object.keys(record).reduce((acc, rec_key) => {\n    acc[rec_key] = convertColumn(rec_key, columns, record, skipTypes)\n    return acc\n  }, {} as Record)\n}\n\n/**\n * Converts the value of an individual column.\n *\n * @param {String} columnName The column that you want to convert\n * @param {{name: String, type: String}[]} columns All of the columns\n * @param {Object} record The map of string values\n * @param {Array} skipTypes An array of types that should not be converted\n * @return {object} Useless information\n *\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, [])\n * //=> 33\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, ['int4'])\n * //=> \"33\"\n */\nexport const convertColumn = (\n  columnName: string,\n  columns: Columns,\n  record: Record,\n  skipTypes: string[]\n): RecordValue => {\n  const column = columns.find((x) => x.name === columnName)\n  const colType = column?.type\n  const value = record[columnName]\n\n  if (colType && !skipTypes.includes(colType)) {\n    return convertCell(colType, value)\n  }\n\n  return noop(value)\n}\n\n/**\n * If the value of the cell is `null`, returns null.\n * Otherwise converts the string value to the correct type.\n * @param {String} type A postgres column type\n * @param {String} stringValue The cell value\n *\n * @example convertCell('bool', 't')\n * //=> true\n * @example convertCell('int8', '10')\n * //=> 10\n * @example convertCell('_int4', '{1,2,3,4}')\n * //=> [1,2,3,4]\n */\nexport const convertCell = (type: string, value: RecordValue): RecordValue => {\n  // if data type is an array\n  if (type.charAt(0) === '_') {\n    const dataType = type.slice(1, type.length)\n    return toArray(value, dataType)\n  }\n\n  // If not null, convert to correct type.\n  switch (type) {\n    case PostgresTypes.bool:\n      return toBoolean(value)\n    case PostgresTypes.float4:\n    case PostgresTypes.float8:\n    case PostgresTypes.int2:\n    case PostgresTypes.int4:\n    case PostgresTypes.int8:\n    case PostgresTypes.numeric:\n    case PostgresTypes.oid:\n      return toNumber(value)\n    case PostgresTypes.json:\n    case PostgresTypes.jsonb:\n      return toJson(value)\n    case PostgresTypes.timestamp:\n      return toTimestampString(value) // Format to be consistent with PostgREST\n    case PostgresTypes.abstime: // To allow users to cast it based on Timezone\n    case PostgresTypes.date: // To allow users to cast it based on Timezone\n    case PostgresTypes.daterange:\n    case PostgresTypes.int4range:\n    case PostgresTypes.int8range:\n    case PostgresTypes.money:\n    case PostgresTypes.reltime: // To allow users to cast it based on Timezone\n    case PostgresTypes.text:\n    case PostgresTypes.time: // To allow users to cast it based on Timezone\n    case PostgresTypes.timestamptz: // To allow users to cast it based on Timezone\n    case PostgresTypes.timetz: // To allow users to cast it based on Timezone\n    case PostgresTypes.tsrange:\n    case PostgresTypes.tstzrange:\n      return noop(value)\n    default:\n      // Return the value for remaining types\n      return noop(value)\n  }\n}\n\nconst noop = (value: RecordValue): RecordValue => {\n  return value\n}\nexport const toBoolean = (value: RecordValue): RecordValue => {\n  switch (value) {\n    case 't':\n      return true\n    case 'f':\n      return false\n    default:\n      return value\n  }\n}\nexport const toNumber = (value: RecordValue): RecordValue => {\n  if (typeof value === 'string') {\n    const parsedValue = parseFloat(value)\n    if (!Number.isNaN(parsedValue)) {\n      return parsedValue\n    }\n  }\n  return value\n}\nexport const toJson = (value: RecordValue): RecordValue => {\n  if (typeof value === 'string') {\n    try {\n      return JSON.parse(value)\n    } catch (error) {\n      console.log(`JSON parse error: ${error}`)\n      return value\n    }\n  }\n  return value\n}\n\n/**\n * Converts a Postgres Array into a native JS array\n *\n * @example toArray('{}', 'int4')\n * //=> []\n * @example toArray('{\"[2021-01-01,2021-12-31)\",\"(2021-01-01,2021-12-32]\"}', 'daterange')\n * //=> ['[2021-01-01,2021-12-31)', '(2021-01-01,2021-12-32]']\n * @example toArray([1,2,3,4], 'int4')\n * //=> [1,2,3,4]\n */\nexport const toArray = (value: RecordValue, type: string): RecordValue => {\n  if (typeof value !== 'string') {\n    return value\n  }\n\n  const lastIdx = value.length - 1\n  const closeBrace = value[lastIdx]\n  const openBrace = value[0]\n\n  // Confirm value is a Postgres array by checking curly brackets\n  if (openBrace === '{' && closeBrace === '}') {\n    let arr\n    const valTrim = value.slice(1, lastIdx)\n\n    // TODO: find a better solution to separate Postgres array data\n    try {\n      arr = JSON.parse('[' + valTrim + ']')\n    } catch (_) {\n      // WARNING: splitting on comma does not cover all edge cases\n      arr = valTrim ? valTrim.split(',') : []\n    }\n\n    return arr.map((val: BaseValue) => convertCell(type, val))\n  }\n\n  return value\n}\n\n/**\n * Fixes timestamp to be ISO-8601. Swaps the space between the date and time for a 'T'\n * See https://github.com/supabase/supabase/issues/18\n *\n * @example toTimestampString('2019-09-10 00:00:00')\n * //=> '2019-09-10T00:00:00'\n */\nexport const toTimestampString = (value: RecordValue): RecordValue => {\n  if (typeof value === 'string') {\n    return value.replace(' ', 'T')\n  }\n\n  return value\n}\n","import { CHANNEL_EVENTS, CHANNEL_STATES } from './lib/constants'\nimport Push from './lib/push'\nimport RealtimeClient from './RealtimeClient'\nimport Timer from './lib/timer'\nimport RealtimePresence, {\n  RealtimePresenceJoinPayload,\n  RealtimePresenceLeavePayload,\n  RealtimePresenceState,\n  REALTIME_PRESENCE_LISTEN_EVENTS,\n} from './RealtimePresence'\nimport * as Transformers from './lib/transformers'\n\nexport type RealtimeChannelOptions = {\n  config: {\n    /**\n     * self option enables client to receive message it broadcast\n     * ack option instructs server to acknowlege that broadcast message was received\n     */\n    broadcast?: { self?: boolean; ack?: boolean }\n    /**\n     * key option is used to track presence payload across clients\n     */\n    presence?: { key?: string }\n  }\n}\n\ntype RealtimePostgresChangesPayloadBase = {\n  schema: string\n  table: string\n  commit_timestamp: string\n  errors: string[]\n}\n\nexport type RealtimePostgresInsertPayload<T extends { [key: string]: any }> =\n  RealtimePostgresChangesPayloadBase & {\n    eventType: `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.INSERT}`\n    new: T\n    old: {}\n  }\n\nexport type RealtimePostgresUpdatePayload<T extends { [key: string]: any }> =\n  RealtimePostgresChangesPayloadBase & {\n    eventType: `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.UPDATE}`\n    new: T\n    old: Partial<T>\n  }\n\nexport type RealtimePostgresDeletePayload<T extends { [key: string]: any }> =\n  RealtimePostgresChangesPayloadBase & {\n    eventType: `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.DELETE}`\n    new: {}\n    old: Partial<T>\n  }\n\nexport type RealtimePostgresChangesPayload<T extends { [key: string]: any }> =\n  | RealtimePostgresInsertPayload<T>\n  | RealtimePostgresUpdatePayload<T>\n  | RealtimePostgresDeletePayload<T>\n\nexport type RealtimePostgresChangesFilter<T extends string> = {\n  event: T\n  schema: string\n  table?: string\n  filter?: string\n}\n\nexport type RealtimeChannelSendResponse = 'ok' | 'timed out' | 'rate limited'\n\nexport enum REALTIME_POSTGRES_CHANGES_LISTEN_EVENT {\n  ALL = '*',\n  INSERT = 'INSERT',\n  UPDATE = 'UPDATE',\n  DELETE = 'DELETE',\n}\n\nexport enum REALTIME_LISTEN_TYPES {\n  BROADCAST = 'broadcast',\n  PRESENCE = 'presence',\n  POSTGRES_CHANGES = 'postgres_changes',\n}\n\nexport enum REALTIME_SUBSCRIBE_STATES {\n  SUBSCRIBED = 'SUBSCRIBED',\n  TIMED_OUT = 'TIMED_OUT',\n  CLOSED = 'CLOSED',\n  CHANNEL_ERROR = 'CHANNEL_ERROR',\n}\n\n/** A channel is the basic building block of Realtime\n * and narrows the scope of data flow to subscribed clients.\n * You can think of a channel as a chatroom where participants are able to see who's online\n * and send and receive messages.\n **/\nexport default class RealtimeChannel {\n  bindings: {\n    [key: string]: {\n      type: string\n      filter: { [key: string]: any }\n      callback: Function\n      id?: string\n    }[]\n  } = {}\n  timeout: number\n  state = CHANNEL_STATES.closed\n  joinedOnce = false\n  joinPush: Push\n  rejoinTimer: Timer\n  pushBuffer: Push[] = []\n  presence: RealtimePresence\n\n  constructor(\n    /** Topic name can be any string. */\n    public topic: string,\n    public params: RealtimeChannelOptions = { config: {} },\n    public socket: RealtimeClient\n  ) {\n    this.params.config = {\n      ...{\n        broadcast: { ack: false, self: false },\n        presence: { key: '' },\n      },\n      ...params.config,\n    }\n    this.timeout = this.socket.timeout\n    this.joinPush = new Push(\n      this,\n      CHANNEL_EVENTS.join,\n      this.params,\n      this.timeout\n    )\n    this.rejoinTimer = new Timer(\n      () => this._rejoinUntilConnected(),\n      this.socket.reconnectAfterMs\n    )\n    this.joinPush.receive('ok', () => {\n      this.state = CHANNEL_STATES.joined\n      this.rejoinTimer.reset()\n      this.pushBuffer.forEach((pushEvent: Push) => pushEvent.send())\n      this.pushBuffer = []\n    })\n    this._onClose(() => {\n      this.rejoinTimer.reset()\n      this.socket.log('channel', `close ${this.topic} ${this._joinRef()}`)\n      this.state = CHANNEL_STATES.closed\n      this.socket._remove(this)\n    })\n    this._onError((reason: string) => {\n      if (this._isLeaving() || this._isClosed()) {\n        return\n      }\n      this.socket.log('channel', `error ${this.topic}`, reason)\n      this.state = CHANNEL_STATES.errored\n      this.rejoinTimer.scheduleTimeout()\n    })\n    this.joinPush.receive('timeout', () => {\n      if (!this._isJoining()) {\n        return\n      }\n      this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout)\n      this.state = CHANNEL_STATES.errored\n      this.rejoinTimer.scheduleTimeout()\n    })\n    this._on(CHANNEL_EVENTS.reply, {}, (payload: any, ref: string) => {\n      this._trigger(this._replyEventName(ref), payload)\n    })\n\n    this.presence = new RealtimePresence(this)\n  }\n\n  /** Subscribe registers your client with the server */\n  subscribe(\n    callback?: (status: `${REALTIME_SUBSCRIBE_STATES}`, err?: Error) => void,\n    timeout = this.timeout\n  ): RealtimeChannel {\n    if (this.joinedOnce) {\n      throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`\n    } else {\n      const {\n        config: { broadcast, presence },\n      } = this.params\n      this._onError((e: Error) => callback && callback('CHANNEL_ERROR', e))\n      this._onClose(() => callback && callback('CLOSED'))\n\n      const accessTokenPayload: { access_token?: string } = {}\n      const config = {\n        broadcast,\n        presence,\n        postgres_changes:\n          this.bindings.postgres_changes?.map((r) => r.filter) ?? [],\n      }\n\n      if (this.socket.accessToken) {\n        accessTokenPayload.access_token = this.socket.accessToken\n      }\n\n      this.updateJoinPayload({ ...{ config }, ...accessTokenPayload })\n\n      this.joinedOnce = true\n      this._rejoin(timeout)\n\n      this.joinPush\n        .receive(\n          'ok',\n          ({\n            postgres_changes: serverPostgresFilters,\n          }: {\n            postgres_changes: {\n              id: string\n              event: string\n              schema?: string\n              table?: string\n              filter?: string\n            }[]\n          }) => {\n            this.socket.accessToken &&\n              this.socket.setAuth(this.socket.accessToken)\n\n            if (serverPostgresFilters === undefined) {\n              callback && callback('SUBSCRIBED')\n              return\n            } else {\n              const clientPostgresBindings = this.bindings.postgres_changes\n              const bindingsLen = clientPostgresBindings?.length ?? 0\n              const newPostgresBindings = []\n\n              for (let i = 0; i < bindingsLen; i++) {\n                const clientPostgresBinding = clientPostgresBindings[i]\n                const {\n                  filter: { event, schema, table, filter },\n                } = clientPostgresBinding\n                const serverPostgresFilter =\n                  serverPostgresFilters && serverPostgresFilters[i]\n\n                if (\n                  serverPostgresFilter &&\n                  serverPostgresFilter.event === event &&\n                  serverPostgresFilter.schema === schema &&\n                  serverPostgresFilter.table === table &&\n                  serverPostgresFilter.filter === filter\n                ) {\n                  newPostgresBindings.push({\n                    ...clientPostgresBinding,\n                    id: serverPostgresFilter.id,\n                  })\n                } else {\n                  this.unsubscribe()\n                  callback &&\n                    callback(\n                      'CHANNEL_ERROR',\n                      new Error(\n                        'mismatch between server and client bindings for postgres changes'\n                      )\n                    )\n                  return\n                }\n              }\n\n              this.bindings.postgres_changes = newPostgresBindings\n\n              callback && callback('SUBSCRIBED')\n              return\n            }\n          }\n        )\n        .receive('error', (error: { [key: string]: any }) => {\n          callback &&\n            callback(\n              'CHANNEL_ERROR',\n              new Error(\n                JSON.stringify(Object.values(error).join(', ') || 'error')\n              )\n            )\n          return\n        })\n        .receive('timeout', () => {\n          callback && callback('TIMED_OUT')\n          return\n        })\n    }\n\n    return this\n  }\n\n  presenceState(): RealtimePresenceState {\n    return this.presence.state\n  }\n\n  async track(\n    payload: { [key: string]: any },\n    opts: { [key: string]: any } = {}\n  ): Promise<RealtimeChannelSendResponse> {\n    return await this.send(\n      {\n        type: 'presence',\n        event: 'track',\n        payload,\n      },\n      opts.timeout || this.timeout\n    )\n  }\n\n  async untrack(\n    opts: { [key: string]: any } = {}\n  ): Promise<RealtimeChannelSendResponse> {\n    return await this.send(\n      {\n        type: 'presence',\n        event: 'untrack',\n      },\n      opts\n    )\n  }\n\n  /** Listen to messages. */\n  on(\n    type: `${REALTIME_LISTEN_TYPES.BROADCAST}`,\n    filter: { event: string },\n    callback: (payload: {\n      type: `${REALTIME_LISTEN_TYPES.BROADCAST}`\n      event: string\n      [key: string]: any\n    }) => void\n  ): RealtimeChannel\n  on(\n    type: `${REALTIME_LISTEN_TYPES.PRESENCE}`,\n    filter: { event: `${REALTIME_PRESENCE_LISTEN_EVENTS.SYNC}` },\n    callback: () => void\n  ): RealtimeChannel\n  on(\n    type: `${REALTIME_LISTEN_TYPES.PRESENCE}`,\n    filter: { event: `${REALTIME_PRESENCE_LISTEN_EVENTS.JOIN}` },\n    callback: (payload: RealtimePresenceJoinPayload) => void\n  ): RealtimeChannel\n  on(\n    type: `${REALTIME_LISTEN_TYPES.PRESENCE}`,\n    filter: { event: `${REALTIME_PRESENCE_LISTEN_EVENTS.LEAVE}` },\n    callback: (payload: RealtimePresenceLeavePayload) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`,\n    filter: RealtimePostgresChangesFilter<`${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.ALL}`>,\n    callback: (payload: RealtimePostgresChangesPayload<T>) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`,\n    filter: RealtimePostgresChangesFilter<`${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.INSERT}`>,\n    callback: (payload: RealtimePostgresInsertPayload<T>) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`,\n    filter: RealtimePostgresChangesFilter<`${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.UPDATE}`>,\n    callback: (payload: RealtimePostgresUpdatePayload<T>) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`,\n    filter: RealtimePostgresChangesFilter<`${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.DELETE}`>,\n    callback: (payload: RealtimePostgresDeletePayload<T>) => void\n  ): RealtimeChannel\n  on(\n    type: `${REALTIME_LISTEN_TYPES}`,\n    filter: { event: string; [key: string]: string },\n    callback: (payload: any) => void\n  ): RealtimeChannel {\n    return this._on(type, filter, callback)\n  }\n\n  send(\n    payload: { type: string; [key: string]: any },\n    opts: { [key: string]: any } = {}\n  ): Promise<RealtimeChannelSendResponse> {\n    return new Promise((resolve) => {\n      const push = this._push(\n        payload.type,\n        payload,\n        opts.timeout || this.timeout\n      )\n\n      if (push.rateLimited) {\n        resolve('rate limited')\n      }\n\n      if (\n        payload.type === 'broadcast' &&\n        !this.params?.config?.broadcast?.ack\n      ) {\n        resolve('ok')\n      }\n\n      push.receive('ok', () => resolve('ok'))\n      push.receive('timeout', () => resolve('timed out'))\n    })\n  }\n\n  updateJoinPayload(payload: { [key: string]: any }): void {\n    this.joinPush.updatePayload(payload)\n  }\n\n  /**\n   * Leaves the channel.\n   *\n   * Unsubscribes from server events, and instructs channel to terminate on server.\n   * Triggers onClose() hooks.\n   *\n   * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n   * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n   */\n  unsubscribe(timeout = this.timeout): Promise<'ok' | 'timed out' | 'error'> {\n    this.state = CHANNEL_STATES.leaving\n    const onClose = () => {\n      this.socket.log('channel', `leave ${this.topic}`)\n      this._trigger(CHANNEL_EVENTS.close, 'leave', this._joinRef())\n    }\n\n    this.rejoinTimer.reset()\n    // Destroy joinPush to avoid connection timeouts during unscription phase\n    this.joinPush.destroy()\n\n    return new Promise((resolve) => {\n      const leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout)\n\n      leavePush\n        .receive('ok', () => {\n          onClose()\n          resolve('ok')\n        })\n        .receive('timeout', () => {\n          onClose()\n          resolve('timed out')\n        })\n        .receive('error', () => {\n          resolve('error')\n        })\n\n      leavePush.send()\n\n      if (!this._canPush()) {\n        leavePush.trigger('ok', {})\n      }\n    })\n  }\n\n  /** @internal */\n  _push(\n    event: string,\n    payload: { [key: string]: any },\n    timeout = this.timeout\n  ) {\n    if (!this.joinedOnce) {\n      throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`\n    }\n    let pushEvent = new Push(this, event, payload, timeout)\n    if (this._canPush()) {\n      pushEvent.send()\n    } else {\n      pushEvent.startTimeout()\n      this.pushBuffer.push(pushEvent)\n    }\n\n    return pushEvent\n  }\n\n  /**\n   * Overridable message hook\n   *\n   * Receives all events for specialized message handling before dispatching to the channel callbacks.\n   * Must return the payload, modified or unmodified.\n   *\n   * @internal\n   */\n  _onMessage(_event: string, payload: any, _ref?: string) {\n    return payload\n  }\n\n  /** @internal */\n  _isMember(topic: string): boolean {\n    return this.topic === topic\n  }\n\n  /** @internal */\n  _joinRef(): string {\n    return this.joinPush.ref\n  }\n\n  /** @internal */\n  _trigger(type: string, payload?: any, ref?: string) {\n    const typeLower = type.toLocaleLowerCase()\n    const { close, error, leave, join } = CHANNEL_EVENTS\n    const events: string[] = [close, error, leave, join]\n    if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {\n      return\n    }\n    let handledPayload = this._onMessage(typeLower, payload, ref)\n    if (payload && !handledPayload) {\n      throw 'channel onMessage callbacks must return the payload, modified or unmodified'\n    }\n\n    if (['insert', 'update', 'delete'].includes(typeLower)) {\n      this.bindings.postgres_changes\n        ?.filter((bind) => {\n          return (\n            bind.filter?.event === '*' ||\n            bind.filter?.event?.toLocaleLowerCase() === typeLower\n          )\n        })\n        .map((bind) => bind.callback(handledPayload, ref))\n    } else {\n      this.bindings[typeLower]\n        ?.filter((bind) => {\n          if (\n            ['broadcast', 'presence', 'postgres_changes'].includes(typeLower)\n          ) {\n            if ('id' in bind) {\n              const bindId = bind.id\n              const bindEvent = bind.filter?.event\n              return (\n                bindId &&\n                payload.ids?.includes(bindId) &&\n                (bindEvent === '*' ||\n                  bindEvent?.toLocaleLowerCase() ===\n                    payload.data?.type.toLocaleLowerCase())\n              )\n            } else {\n              const bindEvent = bind?.filter?.event?.toLocaleLowerCase()\n              return (\n                bindEvent === '*' ||\n                bindEvent === payload?.event?.toLocaleLowerCase()\n              )\n            }\n          } else {\n            return bind.type.toLocaleLowerCase() === typeLower\n          }\n        })\n        .map((bind) => {\n          if (typeof handledPayload === 'object' && 'ids' in handledPayload) {\n            const postgresChanges = handledPayload.data\n            const { schema, table, commit_timestamp, type, errors } =\n              postgresChanges\n            const enrichedPayload = {\n              schema: schema,\n              table: table,\n              commit_timestamp: commit_timestamp,\n              eventType: type,\n              new: {},\n              old: {},\n              errors: errors,\n            }\n            handledPayload = {\n              ...enrichedPayload,\n              ...this._getPayloadRecords(postgresChanges),\n            }\n          }\n          bind.callback(handledPayload, ref)\n        })\n    }\n  }\n\n  /** @internal */\n  _isClosed(): boolean {\n    return this.state === CHANNEL_STATES.closed\n  }\n\n  /** @internal */\n  _isJoined(): boolean {\n    return this.state === CHANNEL_STATES.joined\n  }\n\n  /** @internal */\n  _isJoining(): boolean {\n    return this.state === CHANNEL_STATES.joining\n  }\n\n  /** @internal */\n  _isLeaving(): boolean {\n    return this.state === CHANNEL_STATES.leaving\n  }\n\n  /** @internal */\n  _replyEventName(ref: string): string {\n    return `chan_reply_${ref}`\n  }\n\n  /** @internal */\n  _on(type: string, filter: { [key: string]: any }, callback: Function) {\n    const typeLower = type.toLocaleLowerCase()\n\n    const binding = {\n      type: typeLower,\n      filter: filter,\n      callback: callback,\n    }\n\n    if (this.bindings[typeLower]) {\n      this.bindings[typeLower].push(binding)\n    } else {\n      this.bindings[typeLower] = [binding]\n    }\n\n    return this\n  }\n\n  /** @internal */\n  _off(type: string, filter: { [key: string]: any }) {\n    const typeLower = type.toLocaleLowerCase()\n\n    this.bindings[typeLower] = this.bindings[typeLower].filter((bind) => {\n      return !(\n        bind.type?.toLocaleLowerCase() === typeLower &&\n        RealtimeChannel.isEqual(bind.filter, filter)\n      )\n    })\n    return this\n  }\n\n  /** @internal */\n  private static isEqual(\n    obj1: { [key: string]: string },\n    obj2: { [key: string]: string }\n  ) {\n    if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n      return false\n    }\n\n    for (const k in obj1) {\n      if (obj1[k] !== obj2[k]) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  /** @internal */\n  private _rejoinUntilConnected() {\n    this.rejoinTimer.scheduleTimeout()\n    if (this.socket.isConnected()) {\n      this._rejoin()\n    }\n  }\n\n  /**\n   * Registers a callback that will be executed when the channel closes.\n   *\n   * @internal\n   */\n  private _onClose(callback: Function) {\n    this._on(CHANNEL_EVENTS.close, {}, callback)\n  }\n\n  /**\n   * Registers a callback that will be executed when the channel encounteres an error.\n   *\n   * @internal\n   */\n  private _onError(callback: Function) {\n    this._on(CHANNEL_EVENTS.error, {}, (reason: string) => callback(reason))\n  }\n\n  /**\n   * Returns `true` if the socket is connected and the channel has been joined.\n   *\n   * @internal\n   */\n  private _canPush(): boolean {\n    return this.socket.isConnected() && this._isJoined()\n  }\n\n  /** @internal */\n  private _rejoin(timeout = this.timeout): void {\n    if (this._isLeaving()) {\n      return\n    }\n    this.socket._leaveOpenTopic(this.topic)\n    this.state = CHANNEL_STATES.joining\n    this.joinPush.resend(timeout)\n  }\n\n  /** @internal */\n  private _getPayloadRecords(payload: any) {\n    const records = {\n      new: {},\n      old: {},\n    }\n\n    if (payload.type === 'INSERT' || payload.type === 'UPDATE') {\n      records.new = Transformers.convertChangeData(\n        payload.columns,\n        payload.record\n      )\n    }\n\n    if (payload.type === 'UPDATE' || payload.type === 'DELETE') {\n      records.old = Transformers.convertChangeData(\n        payload.columns,\n        payload.old_record\n      )\n    }\n\n    return records\n  }\n}\n","import { w3cwebsocket } from 'websocket'\nimport {\n  VSN,\n  CHANNEL_EVENTS,\n  TRANSPORTS,\n  SOCKET_STATES,\n  DEFAULT_TIMEOUT,\n  WS_CLOSE_NORMAL,\n  DEFAULT_HEADERS,\n  CONNECTION_STATE,\n} from './lib/constants'\nimport Timer from './lib/timer'\nimport Serializer from './lib/serializer'\nimport RealtimeChannel, { RealtimeChannelOptions } from './RealtimeChannel'\n\nexport type RealtimeClientOptions = {\n  transport?: WebSocket\n  timeout?: number\n  heartbeatIntervalMs?: number\n  logger?: Function\n  encode?: Function\n  decode?: Function\n  reconnectAfterMs?: Function\n  headers?: { [key: string]: string }\n  params?: { [key: string]: any }\n}\n\nexport type RealtimeMessage = {\n  topic: string\n  event: string\n  payload: any\n  ref: string\n  join_ref?: string\n}\n\nexport type RealtimeRemoveChannelResponse = 'ok' | 'timed out' | 'error'\n\nconst noop = () => {}\n\nexport default class RealtimeClient {\n  accessToken: string | null = null\n  channels: RealtimeChannel[] = []\n  endPoint: string = ''\n  headers?: { [key: string]: string } = DEFAULT_HEADERS\n  params?: { [key: string]: string } = {}\n  timeout: number = DEFAULT_TIMEOUT\n  transport: any = w3cwebsocket\n  heartbeatIntervalMs: number = 30000\n  heartbeatTimer: ReturnType<typeof setInterval> | undefined = undefined\n  pendingHeartbeatRef: string | null = null\n  ref: number = 0\n  reconnectTimer: Timer\n  logger: Function = noop\n  encode: Function\n  decode: Function\n  reconnectAfterMs: Function\n  conn: WebSocket | null = null\n  sendBuffer: Function[] = []\n  serializer: Serializer = new Serializer()\n  stateChangeCallbacks: {\n    open: Function[]\n    close: Function[]\n    error: Function[]\n    message: Function[]\n  } = {\n    open: [],\n    close: [],\n    error: [],\n    message: [],\n  }\n  eventsPerSecondLimitMs: number = 100\n  inThrottle: boolean = false\n\n  /**\n   * Initializes the Socket.\n   *\n   * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n   * @param options.transport The Websocket Transport, for example WebSocket.\n   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n   * @param options.params The optional params to pass when connecting.\n   * @param options.headers The optional headers to pass when connecting.\n   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n   */\n  constructor(endPoint: string, options?: RealtimeClientOptions) {\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`\n\n    if (options?.params) this.params = options.params\n    if (options?.headers) this.headers = { ...this.headers, ...options.headers }\n    if (options?.timeout) this.timeout = options.timeout\n    if (options?.logger) this.logger = options.logger\n    if (options?.transport) this.transport = options.transport\n    if (options?.heartbeatIntervalMs)\n      this.heartbeatIntervalMs = options.heartbeatIntervalMs\n\n    const eventsPerSecond = options?.params?.eventsPerSecond\n    if (eventsPerSecond)\n      this.eventsPerSecondLimitMs = Math.floor(1000 / eventsPerSecond)\n\n    this.reconnectAfterMs = options?.reconnectAfterMs\n      ? options.reconnectAfterMs\n      : (tries: number) => {\n          return [1000, 2000, 5000, 10000][tries - 1] || 10000\n        }\n    this.encode = options?.encode\n      ? options.encode\n      : (payload: JSON, callback: Function) => {\n          return callback(JSON.stringify(payload))\n        }\n    this.decode = options?.decode\n      ? options.decode\n      : this.serializer.decode.bind(this.serializer)\n    this.reconnectTimer = new Timer(async () => {\n      this.disconnect()\n      this.connect()\n    }, this.reconnectAfterMs)\n  }\n\n  /**\n   * Connects the socket, unless already connected.\n   */\n  connect(): void {\n    if (this.conn) {\n      return\n    }\n\n    this.conn = new this.transport(this._endPointURL(), [], null, this.headers)\n\n    if (this.conn) {\n      this.conn.binaryType = 'arraybuffer'\n      this.conn.onopen = () => this._onConnOpen()\n      this.conn.onerror = (error) => this._onConnError(error as ErrorEvent)\n      this.conn.onmessage = (event) => this._onConnMessage(event)\n      this.conn.onclose = (event) => this._onConnClose(event)\n    }\n  }\n\n  /**\n   * Disconnects the socket.\n   *\n   * @param code A numeric status code to send on disconnect.\n   * @param reason A custom reason for the disconnect.\n   */\n  disconnect(code?: number, reason?: string): void {\n    if (this.conn) {\n      this.conn.onclose = function () {} // noop\n      if (code) {\n        this.conn.close(code, reason ?? '')\n      } else {\n        this.conn.close()\n      }\n      this.conn = null\n      // remove open handles\n      this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n      this.reconnectTimer.reset()\n    }\n  }\n\n  getChannels(): RealtimeChannel[] {\n    return this.channels\n  }\n\n  removeChannel(\n    channel: RealtimeChannel\n  ): Promise<RealtimeRemoveChannelResponse> {\n    return channel.unsubscribe().then((status) => {\n      if (this.channels.length === 0) {\n        this.disconnect()\n      }\n      return status\n    })\n  }\n\n  removeAllChannels(): Promise<RealtimeRemoveChannelResponse[]> {\n    return Promise.all(\n      this.channels.map((channel) => channel.unsubscribe())\n    ).then((values) => {\n      this.disconnect()\n      return values\n    })\n  }\n\n  /**\n   * Logs the message.\n   *\n   * For customized logging, `this.logger` can be overriden.\n   */\n  log(kind: string, msg: string, data?: any) {\n    this.logger(kind, msg, data)\n  }\n\n  /**\n   * Returns the current state of the socket.\n   */\n  connectionState(): CONNECTION_STATE {\n    switch (this.conn && this.conn.readyState) {\n      case SOCKET_STATES.connecting:\n        return CONNECTION_STATE.Connecting\n      case SOCKET_STATES.open:\n        return CONNECTION_STATE.Open\n      case SOCKET_STATES.closing:\n        return CONNECTION_STATE.Closing\n      default:\n        return CONNECTION_STATE.Closed\n    }\n  }\n\n  /**\n   * Retuns `true` is the connection is open.\n   */\n  isConnected(): boolean {\n    return this.connectionState() === CONNECTION_STATE.Open\n  }\n\n  channel(\n    topic: string,\n    params: RealtimeChannelOptions = { config: {} }\n  ): RealtimeChannel {\n    if (!this.isConnected()) {\n      this.connect()\n    }\n\n    const chan = new RealtimeChannel(`realtime:${topic}`, params, this)\n    this.channels.push(chan)\n    return chan\n  }\n\n  /**\n   * Push out a message if the socket is connected.\n   *\n   * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n   */\n  push(data: RealtimeMessage): 'rate limited' | void {\n    const { topic, event, payload, ref } = data\n    let callback = () => {\n      this.encode(data, (result: any) => {\n        this.conn?.send(result)\n      })\n    }\n    this.log('push', `${topic} ${event} (${ref})`, payload)\n    if (this.isConnected()) {\n      if (['broadcast', 'presence', 'postgres_changes'].includes(event)) {\n        const isThrottled = this._throttle(callback)()\n        if (isThrottled) {\n          return 'rate limited'\n        }\n      } else {\n        callback()\n      }\n    } else {\n      this.sendBuffer.push(callback)\n    }\n  }\n\n  /**\n   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n   *\n   * @param token A JWT string.\n   */\n  setAuth(token: string | null): void {\n    this.accessToken = token\n\n    this.channels.forEach((channel) => {\n      token && channel.updateJoinPayload({ access_token: token })\n\n      if (channel.joinedOnce && channel._isJoined()) {\n        channel._push(CHANNEL_EVENTS.access_token, { access_token: token })\n      }\n    })\n  }\n\n  /**\n   * Return the next message ref, accounting for overflows\n   *\n   * @internal\n   */\n  _makeRef(): string {\n    let newRef = this.ref + 1\n    if (newRef === this.ref) {\n      this.ref = 0\n    } else {\n      this.ref = newRef\n    }\n\n    return this.ref.toString()\n  }\n\n  /**\n   * Unsubscribe from channels with the specified topic.\n   *\n   * @internal\n   */\n  _leaveOpenTopic(topic: string): void {\n    let dupChannel = this.channels.find(\n      (c) => c.topic === topic && (c._isJoined() || c._isJoining())\n    )\n    if (dupChannel) {\n      this.log('transport', `leaving duplicate topic \"${topic}\"`)\n      dupChannel.unsubscribe()\n    }\n  }\n\n  /**\n   * Removes a subscription from the socket.\n   *\n   * @param channel An open subscription.\n   *\n   * @internal\n   */\n  _remove(channel: RealtimeChannel) {\n    this.channels = this.channels.filter(\n      (c: RealtimeChannel) => c._joinRef() !== channel._joinRef()\n    )\n  }\n\n  /**\n   * Returns the URL of the websocket.\n   *\n   * @internal\n   */\n  private _endPointURL(): string {\n    return this._appendParams(\n      this.endPoint,\n      Object.assign({}, this.params, { vsn: VSN })\n    )\n  }\n\n  /** @internal */\n  private _onConnMessage(rawMessage: { data: any }) {\n    this.decode(rawMessage.data, (msg: RealtimeMessage) => {\n      let { topic, event, payload, ref } = msg\n\n      if (\n        (ref && ref === this.pendingHeartbeatRef) ||\n        event === payload?.type\n      ) {\n        this.pendingHeartbeatRef = null\n      }\n\n      this.log(\n        'receive',\n        `${payload.status || ''} ${topic} ${event} ${\n          (ref && '(' + ref + ')') || ''\n        }`,\n        payload\n      )\n      this.channels\n        .filter((channel: RealtimeChannel) => channel._isMember(topic))\n        .forEach((channel: RealtimeChannel) =>\n          channel._trigger(event, payload, ref)\n        )\n      this.stateChangeCallbacks.message.forEach((callback) => callback(msg))\n    })\n  }\n\n  /** @internal */\n  private _onConnOpen() {\n    this.log('transport', `connected to ${this._endPointURL()}`)\n    this._flushSendBuffer()\n    this.reconnectTimer.reset()\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n    this.heartbeatTimer = setInterval(\n      () => this._sendHeartbeat(),\n      this.heartbeatIntervalMs\n    )\n    this.stateChangeCallbacks.open.forEach((callback) => callback())!\n  }\n\n  /** @internal */\n  private _onConnClose(event: any) {\n    this.log('transport', 'close', event)\n    this._triggerChanError()\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n    this.reconnectTimer.scheduleTimeout()\n    this.stateChangeCallbacks.close.forEach((callback) => callback(event))\n  }\n\n  /** @internal */\n  private _onConnError(error: ErrorEvent) {\n    this.log('transport', error.message)\n    this._triggerChanError()\n    this.stateChangeCallbacks.error.forEach((callback) => callback(error))\n  }\n\n  /** @internal */\n  private _triggerChanError() {\n    this.channels.forEach((channel: RealtimeChannel) =>\n      channel._trigger(CHANNEL_EVENTS.error)\n    )\n  }\n\n  /** @internal */\n  private _appendParams(\n    url: string,\n    params: { [key: string]: string }\n  ): string {\n    if (Object.keys(params).length === 0) {\n      return url\n    }\n    const prefix = url.match(/\\?/) ? '&' : '?'\n    const query = new URLSearchParams(params)\n\n    return `${url}${prefix}${query}`\n  }\n\n  /** @internal */\n  private _flushSendBuffer() {\n    if (this.isConnected() && this.sendBuffer.length > 0) {\n      this.sendBuffer.forEach((callback) => callback())\n      this.sendBuffer = []\n    }\n  }\n  /** @internal */\n  private _sendHeartbeat() {\n    if (!this.isConnected()) {\n      return\n    }\n    if (this.pendingHeartbeatRef) {\n      this.pendingHeartbeatRef = null\n      this.log(\n        'transport',\n        'heartbeat timeout. Attempting to re-establish connection'\n      )\n      this.conn?.close(WS_CLOSE_NORMAL, 'hearbeat timeout')\n      return\n    }\n    this.pendingHeartbeatRef = this._makeRef()\n    this.push({\n      topic: 'phoenix',\n      event: 'heartbeat',\n      payload: {},\n      ref: this.pendingHeartbeatRef,\n    })\n    this.setAuth(this.accessToken)\n  }\n\n  /** @internal */\n  private _throttle(\n    callback: Function,\n    eventsPerSecondLimit: number = this.eventsPerSecondLimitMs\n  ): () => boolean {\n    return () => {\n      if (this.inThrottle) return true\n      callback()\n      this.inThrottle = true\n      setTimeout(() => {\n        this.inThrottle = false\n      }, eventsPerSecondLimit)\n      return false\n    }\n  }\n}\n","export class StorageError extends Error {\n  protected __isStorageError = true\n\n  constructor(message: string) {\n    super(message)\n    this.name = 'StorageError'\n  }\n}\n\nexport function isStorageError(error: unknown): error is StorageError {\n  return typeof error === 'object' && error !== null && '__isStorageError' in error\n}\n\nexport class StorageApiError extends StorageError {\n  status: number\n\n  constructor(message: string, status: number) {\n    super(message)\n    this.name = 'StorageApiError'\n    this.status = status\n  }\n\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      status: this.status,\n    }\n  }\n}\n\nexport class StorageUnknownError extends StorageError {\n  originalError: unknown\n\n  constructor(message: string, originalError: unknown) {\n    super(message)\n    this.name = 'StorageUnknownError'\n    this.originalError = originalError\n  }\n}\n","type Fetch = typeof fetch\n\nexport const resolveFetch = (customFetch?: Fetch): Fetch => {\n  let _fetch: Fetch\n  if (customFetch) {\n    _fetch = customFetch\n  } else if (typeof fetch === 'undefined') {\n    _fetch = async (...args) => await (await import('cross-fetch')).fetch(...args)\n  } else {\n    _fetch = fetch\n  }\n  return (...args) => _fetch(...args)\n}\n\nexport const resolveResponse = async () => {\n  if (typeof Response === 'undefined') {\n    return (await import('cross-fetch')).Response\n  }\n\n  return Response\n}\n","import { StorageApiError, StorageUnknownError } from './errors'\nimport { resolveResponse } from './helpers'\nimport { FetchParameters } from './types'\n\nexport type Fetch = typeof fetch\n\nexport interface FetchOptions {\n  headers?: {\n    [key: string]: string\n  }\n  noResolveJson?: boolean\n}\n\nexport type RequestMethodType = 'GET' | 'POST' | 'PUT' | 'DELETE'\n\nconst _getErrorMessage = (err: any): string =>\n  err.msg || err.message || err.error_description || err.error || JSON.stringify(err)\n\nconst handleError = async (error: unknown, reject: (reason?: any) => void) => {\n  const Res = await resolveResponse()\n\n  if (error instanceof Res) {\n    error.json().then((err) => {\n      reject(new StorageApiError(_getErrorMessage(err), error.status || 500))\n    })\n  } else {\n    reject(new StorageUnknownError(_getErrorMessage(error), error))\n  }\n}\n\nconst _getRequestParams = (\n  method: RequestMethodType,\n  options?: FetchOptions,\n  parameters?: FetchParameters,\n  body?: object\n) => {\n  const params: { [k: string]: any } = { method, headers: options?.headers || {} }\n\n  if (method === 'GET') {\n    return params\n  }\n\n  params.headers = { 'Content-Type': 'application/json', ...options?.headers }\n  params.body = JSON.stringify(body)\n  return { ...params, ...parameters }\n}\n\nasync function _handleRequest(\n  fetcher: Fetch,\n  method: RequestMethodType,\n  url: string,\n  options?: FetchOptions,\n  parameters?: FetchParameters,\n  body?: object\n): Promise<any> {\n  return new Promise((resolve, reject) => {\n    fetcher(url, _getRequestParams(method, options, parameters, body))\n      .then((result) => {\n        if (!result.ok) throw result\n        if (options?.noResolveJson) return result\n        return result.json()\n      })\n      .then((data) => resolve(data))\n      .catch((error) => handleError(error, reject))\n  })\n}\n\nexport async function get(\n  fetcher: Fetch,\n  url: string,\n  options?: FetchOptions,\n  parameters?: FetchParameters\n): Promise<any> {\n  return _handleRequest(fetcher, 'GET', url, options, parameters)\n}\n\nexport async function post(\n  fetcher: Fetch,\n  url: string,\n  body: object,\n  options?: FetchOptions,\n  parameters?: FetchParameters\n): Promise<any> {\n  return _handleRequest(fetcher, 'POST', url, options, parameters, body)\n}\n\nexport async function put(\n  fetcher: Fetch,\n  url: string,\n  body: object,\n  options?: FetchOptions,\n  parameters?: FetchParameters\n): Promise<any> {\n  return _handleRequest(fetcher, 'PUT', url, options, parameters, body)\n}\n\nexport async function remove(\n  fetcher: Fetch,\n  url: string,\n  body: object,\n  options?: FetchOptions,\n  parameters?: FetchParameters\n): Promise<any> {\n  return _handleRequest(fetcher, 'DELETE', url, options, parameters, body)\n}\n","import { isStorageError, StorageError } from '../lib/errors'\nimport { Fetch, get, post, remove } from '../lib/fetch'\nimport { resolveFetch } from '../lib/helpers'\nimport { FileObject, FileOptions, SearchOptions, FetchParameters } from '../lib/types'\n\nconst DEFAULT_SEARCH_OPTIONS = {\n  limit: 100,\n  offset: 0,\n  sortBy: {\n    column: 'name',\n    order: 'asc',\n  },\n}\n\nconst DEFAULT_FILE_OPTIONS: FileOptions = {\n  cacheControl: '3600',\n  contentType: 'text/plain;charset=UTF-8',\n  upsert: false,\n}\n\nexport default class StorageFileApi {\n  protected url: string\n  protected headers: { [key: string]: string }\n  protected bucketId?: string\n  protected fetch: Fetch\n\n  constructor(\n    url: string,\n    headers: { [key: string]: string } = {},\n    bucketId?: string,\n    fetch?: Fetch\n  ) {\n    this.url = url\n    this.headers = headers\n    this.bucketId = bucketId\n    this.fetch = resolveFetch(fetch)\n  }\n\n  /**\n   * Uploads a file to an existing bucket or replaces an existing file at the specified path with a new one.\n   *\n   * @param method HTTP method.\n   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n   * @param fileBody The body of the file to be stored in the bucket.\n   */\n  private async uploadOrUpdate(\n    method: 'POST' | 'PUT',\n    path: string,\n    fileBody:\n      | ArrayBuffer\n      | ArrayBufferView\n      | Blob\n      | Buffer\n      | File\n      | FormData\n      | NodeJS.ReadableStream\n      | ReadableStream<Uint8Array>\n      | URLSearchParams\n      | string,\n    fileOptions?: FileOptions\n  ): Promise<\n    | {\n        data: { path: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      let body\n      const options = { ...DEFAULT_FILE_OPTIONS, ...fileOptions }\n      const headers: Record<string, string> = {\n        ...this.headers,\n        ...(method === 'POST' && { 'x-upsert': String(options.upsert as boolean) }),\n      }\n\n      if (typeof Blob !== 'undefined' && fileBody instanceof Blob) {\n        body = new FormData()\n        body.append('cacheControl', options.cacheControl as string)\n        body.append('', fileBody)\n      } else if (typeof FormData !== 'undefined' && fileBody instanceof FormData) {\n        body = fileBody\n        body.append('cacheControl', options.cacheControl as string)\n      } else {\n        body = fileBody\n        headers['cache-control'] = `max-age=${options.cacheControl}`\n        headers['content-type'] = options.contentType as string\n      }\n\n      const cleanPath = this._removeEmptyFolders(path)\n      const _path = this._getFinalPath(cleanPath)\n      const res = await this.fetch(`${this.url}/object/${_path}`, {\n        method,\n        body: body as BodyInit,\n        headers,\n      })\n\n      if (res.ok) {\n        return {\n          data: { path: cleanPath },\n          error: null,\n        }\n      } else {\n        const error = await res.json()\n        return { data: null, error }\n      }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Uploads a file to an existing bucket.\n   *\n   * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n   * @param fileBody The body of the file to be stored in the bucket.\n   */\n  async upload(\n    path: string,\n    fileBody:\n      | ArrayBuffer\n      | ArrayBufferView\n      | Blob\n      | Buffer\n      | File\n      | FormData\n      | NodeJS.ReadableStream\n      | ReadableStream<Uint8Array>\n      | URLSearchParams\n      | string,\n    fileOptions?: FileOptions\n  ): Promise<\n    | {\n        data: { path: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    return this.uploadOrUpdate('POST', path, fileBody, fileOptions)\n  }\n\n  /**\n   * Replaces an existing file at the specified path with a new one.\n   *\n   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to update.\n   * @param fileBody The body of the file to be stored in the bucket.\n   */\n  async update(\n    path: string,\n    fileBody:\n      | ArrayBuffer\n      | ArrayBufferView\n      | Blob\n      | Buffer\n      | File\n      | FormData\n      | NodeJS.ReadableStream\n      | ReadableStream<Uint8Array>\n      | URLSearchParams\n      | string,\n    fileOptions?: FileOptions\n  ): Promise<\n    | {\n        data: { path: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    return this.uploadOrUpdate('PUT', path, fileBody, fileOptions)\n  }\n\n  /**\n   * Moves an existing file to a new path in the same bucket.\n   *\n   * @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n   * @param toPath The new file path, including the new file name. For example `folder/image-new.png`.\n   */\n  async move(\n    fromPath: string,\n    toPath: string\n  ): Promise<\n    | {\n        data: { message: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await post(\n        this.fetch,\n        `${this.url}/object/move`,\n        { bucketId: this.bucketId, sourceKey: fromPath, destinationKey: toPath },\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Copies an existing file to a new path in the same bucket.\n   *\n   * @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n   * @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.\n   */\n  async copy(\n    fromPath: string,\n    toPath: string\n  ): Promise<\n    | {\n        data: { path: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await post(\n        this.fetch,\n        `${this.url}/object/copy`,\n        { bucketId: this.bucketId, sourceKey: fromPath, destinationKey: toPath },\n        { headers: this.headers }\n      )\n      return { data: { path: data.Key }, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Creates a signed URL. Use a signed URL to share a file for a fixed amount of time.\n   *\n   * @param path The file path, including the current file name. For example `folder/image.png`.\n   * @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.\n   * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n   */\n  async createSignedUrl(\n    path: string,\n    expiresIn: number,\n    options?: { download: string | boolean }\n  ): Promise<\n    | {\n        data: { signedUrl: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const _path = this._getFinalPath(path)\n      let data = await post(\n        this.fetch,\n        `${this.url}/object/sign/${_path}`,\n        { expiresIn },\n        { headers: this.headers }\n      )\n      const downloadQueryParam = options?.download\n        ? `&download=${options.download === true ? '' : options.download}`\n        : ''\n      const signedUrl = encodeURI(`${this.url}${data.signedURL}${downloadQueryParam}`)\n      data = { signedUrl }\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Creates multiple signed URLs. Use a signed URL to share a file for a fixed amount of time.\n   *\n   * @param paths The file paths to be downloaded, including the current file names. For example `['folder/image.png', 'folder2/image2.png']`.\n   * @param expiresIn The number of seconds until the signed URLs expire. For example, `60` for URLs which are valid for one minute.\n   * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n   */\n  async createSignedUrls(\n    paths: string[],\n    expiresIn: number,\n    options?: { download: string | boolean }\n  ): Promise<\n    | {\n        data: { error: string | null; path: string | null; signedUrl: string }[]\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await post(\n        this.fetch,\n        `${this.url}/object/sign/${this.bucketId}`,\n        { expiresIn, paths },\n        { headers: this.headers }\n      )\n\n      const downloadQueryParam = options?.download\n        ? `&download=${options.download === true ? '' : options.download}`\n        : ''\n      return {\n        data: data.map((datum: { signedURL: string }) => ({\n          ...datum,\n          signedUrl: datum.signedURL\n            ? encodeURI(`${this.url}${datum.signedURL}${downloadQueryParam}`)\n            : null,\n        })),\n        error: null,\n      }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Downloads a file.\n   *\n   * @param path The full path and file name of the file to be downloaded. For example `folder/image.png`.\n   */\n  async download(\n    path: string\n  ): Promise<\n    | {\n        data: Blob\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const _path = this._getFinalPath(path)\n      const res = await get(this.fetch, `${this.url}/object/${_path}`, {\n        headers: this.headers,\n        noResolveJson: true,\n      })\n      const data = await res.blob()\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Retrieves the URL for an asset in a public bucket.\n   * This function does not verify if the bucket is public. If a public URL is created for a bucket which is not public, you will not be able to download the asset.\n   *\n   * @param path The path and name of the file to generate the public URL for. For example `folder/image.png`.\n   * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n   */\n  getPublicUrl(\n    path: string,\n    options?: { download: string | boolean }\n  ): { data: { publicUrl: string } } {\n    const _path = this._getFinalPath(path)\n    const downloadQueryParam = options?.download\n      ? `?download=${options.download === true ? '' : options.download}`\n      : ''\n\n    return {\n      data: { publicUrl: encodeURI(`${this.url}/object/public/${_path}${downloadQueryParam}`) },\n    }\n  }\n\n  /**\n   * Deletes files within the same bucket\n   *\n   * @param paths An array of files to delete, including the path and file name. For example [`'folder/image.png'`].\n   */\n  async remove(\n    paths: string[]\n  ): Promise<\n    | {\n        data: FileObject[]\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await remove(\n        this.fetch,\n        `${this.url}/object/${this.bucketId}`,\n        { prefixes: paths },\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Get file metadata\n   * @param id the file id to retrieve metadata\n   */\n  // async getMetadata(\n  //   id: string\n  // ): Promise<\n  //   | {\n  //       data: Metadata\n  //       error: null\n  //     }\n  //   | {\n  //       data: null\n  //       error: StorageError\n  //     }\n  // > {\n  //   try {\n  //     const data = await get(this.fetch, `${this.url}/metadata/${id}`, { headers: this.headers })\n  //     return { data, error: null }\n  //   } catch (error) {\n  //     if (isStorageError(error)) {\n  //       return { data: null, error }\n  //     }\n\n  //     throw error\n  //   }\n  // }\n\n  /**\n   * Update file metadata\n   * @param id the file id to update metadata\n   * @param meta the new file metadata\n   */\n  // async updateMetadata(\n  //   id: string,\n  //   meta: Metadata\n  // ): Promise<\n  //   | {\n  //       data: Metadata\n  //       error: null\n  //     }\n  //   | {\n  //       data: null\n  //       error: StorageError\n  //     }\n  // > {\n  //   try {\n  //     const data = await post(\n  //       this.fetch,\n  //       `${this.url}/metadata/${id}`,\n  //       { ...meta },\n  //       { headers: this.headers }\n  //     )\n  //     return { data, error: null }\n  //   } catch (error) {\n  //     if (isStorageError(error)) {\n  //       return { data: null, error }\n  //     }\n\n  //     throw error\n  //   }\n  // }\n\n  /**\n   * Lists all the files within a bucket.\n   * @param path The folder path.\n   */\n  async list(\n    path?: string,\n    options?: SearchOptions,\n    parameters?: FetchParameters\n  ): Promise<\n    | {\n        data: FileObject[]\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const body = { ...DEFAULT_SEARCH_OPTIONS, ...options, prefix: path || '' }\n      const data = await post(\n        this.fetch,\n        `${this.url}/object/list/${this.bucketId}`,\n        body,\n        { headers: this.headers },\n        parameters\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  private _getFinalPath(path: string) {\n    return `${this.bucketId}/${path}`\n  }\n\n  private _removeEmptyFolders(path: string) {\n    return path.replace(/^\\/|\\/$/g, '').replace(/\\/+/g, '/')\n  }\n}\n","import { version } from './version'\nexport const DEFAULT_HEADERS = { 'X-Client-Info': `storage-js/${version}` }\n","// generated by genversion\nexport const version = '2.0.0'\n","import { DEFAULT_HEADERS } from '../lib/constants'\nimport { isStorageError, StorageError } from '../lib/errors'\nimport { Fetch, get, post, put, remove } from '../lib/fetch'\nimport { resolveFetch } from '../lib/helpers'\nimport { Bucket } from '../lib/types'\n\nexport default class StorageBucketApi {\n  protected url: string\n  protected headers: { [key: string]: string }\n  protected fetch: Fetch\n\n  constructor(url: string, headers: { [key: string]: string } = {}, fetch?: Fetch) {\n    this.url = url\n    this.headers = { ...DEFAULT_HEADERS, ...headers }\n    this.fetch = resolveFetch(fetch)\n  }\n\n  /**\n   * Retrieves the details of all Storage buckets within an existing project.\n   */\n  async listBuckets(): Promise<\n    | {\n        data: Bucket[]\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await get(this.fetch, `${this.url}/bucket`, { headers: this.headers })\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Retrieves the details of an existing Storage bucket.\n   *\n   * @param id The unique identifier of the bucket you would like to retrieve.\n   */\n  async getBucket(\n    id: string\n  ): Promise<\n    | {\n        data: Bucket\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await get(this.fetch, `${this.url}/bucket/${id}`, { headers: this.headers })\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Creates a new Storage bucket\n   *\n   * @param id A unique identifier for the bucket you are creating.\n   * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations. By default, buckets are private.\n   * @returns newly created bucket id\n   */\n  async createBucket(\n    id: string,\n    options: { public: boolean } = { public: false }\n  ): Promise<\n    | {\n        data: Pick<Bucket, 'name'>\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await post(\n        this.fetch,\n        `${this.url}/bucket`,\n        { id, name: id, public: options.public },\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Updates a Storage bucket\n   *\n   * @param id A unique identifier for the bucket you are updating.\n   * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations.\n   */\n  async updateBucket(\n    id: string,\n    options: { public: boolean }\n  ): Promise<\n    | {\n        data: { message: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await put(\n        this.fetch,\n        `${this.url}/bucket/${id}`,\n        { id, name: id, public: options.public },\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Removes all objects inside a single bucket.\n   *\n   * @param id The unique identifier of the bucket you would like to empty.\n   */\n  async emptyBucket(\n    id: string\n  ): Promise<\n    | {\n        data: { message: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await post(\n        this.fetch,\n        `${this.url}/bucket/${id}/empty`,\n        {},\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Deletes an existing bucket. A bucket can't be deleted with existing objects inside it.\n   * You must first `empty()` the bucket.\n   *\n   * @param id The unique identifier of the bucket you would like to delete.\n   */\n  async deleteBucket(\n    id: string\n  ): Promise<\n    | {\n        data: { message: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await remove(\n        this.fetch,\n        `${this.url}/bucket/${id}`,\n        {},\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n}\n","import StorageFileApi from './packages/StorageFileApi'\nimport StorageBucketApi from './packages/StorageBucketApi'\nimport { Fetch } from './lib/fetch'\n\nexport class StorageClient extends StorageBucketApi {\n  constructor(url: string, headers: { [key: string]: string } = {}, fetch?: Fetch) {\n    super(url, headers, fetch)\n  }\n\n  /**\n   * Perform file operation in a bucket.\n   *\n   * @param id The bucket id to operate on.\n   */\n  from(id: string): StorageFileApi {\n    return new StorageFileApi(this.url, this.headers, id, this.fetch)\n  }\n}\n","// constants.ts\nimport { version } from './version'\nexport const DEFAULT_HEADERS = { 'X-Client-Info': `supabase-js/${version}` }\n","export const version = '2.1.0'\n","import crossFetch, { Headers as CrossFetchHeaders } from 'cross-fetch'\n\ntype Fetch = typeof fetch\n\nexport const resolveFetch = (customFetch?: Fetch): Fetch => {\n  let _fetch: Fetch\n  if (customFetch) {\n    _fetch = customFetch\n  } else if (typeof fetch === 'undefined') {\n    _fetch = crossFetch as unknown as Fetch\n  } else {\n    _fetch = fetch\n  }\n  return (...args) => _fetch(...args)\n}\n\nexport const resolveHeadersConstructor = () => {\n  if (typeof Headers === 'undefined') {\n    return CrossFetchHeaders\n  }\n\n  return Headers\n}\n\nexport const fetchWithAuth = (\n  supabaseKey: string,\n  getAccessToken: () => Promise<string | null>,\n  customFetch?: Fetch\n): Fetch => {\n  const fetch = resolveFetch(customFetch)\n  const HeadersConstructor = resolveHeadersConstructor()\n\n  return async (input, init) => {\n    const accessToken = (await getAccessToken()) ?? supabaseKey\n    let headers = new HeadersConstructor(init?.headers)\n\n    if (!headers.has('apikey')) {\n      headers.set('apikey', supabaseKey)\n    }\n\n    if (!headers.has('Authorization')) {\n      headers.set('Authorization', `Bearer ${accessToken}`)\n    }\n\n    return fetch(input, { ...init, headers })\n  }\n}\n","import { SupportedStorage } from './types'\n\nexport function expiresAt(expiresIn: number) {\n  const timeNow = Math.round(Date.now() / 1000)\n  return timeNow + expiresIn\n}\n\nexport function uuid() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    const r = (Math.random() * 16) | 0,\n      v = c == 'x' ? r : (r & 0x3) | 0x8\n    return v.toString(16)\n  })\n}\n\nexport const isBrowser = () => typeof window !== 'undefined'\n\nexport function getParameterByName(name: string, url?: string) {\n  if (!url) url = window?.location?.href || ''\n  // eslint-disable-next-line no-useless-escape\n  name = name.replace(/[\\[\\]]/g, '\\\\$&')\n  const regex = new RegExp('[?&#]' + name + '(=([^&#]*)|&|#|$)'),\n    results = regex.exec(url)\n  if (!results) return null\n  if (!results[2]) return ''\n  return decodeURIComponent(results[2].replace(/\\+/g, ' '))\n}\n\ntype Fetch = typeof fetch\n\nexport const resolveFetch = (customFetch?: Fetch): Fetch => {\n  let _fetch: Fetch\n  if (customFetch) {\n    _fetch = customFetch\n  } else if (typeof fetch === 'undefined') {\n    _fetch = async (...args) => await (await import('cross-fetch')).fetch(...args)\n  } else {\n    _fetch = fetch\n  }\n  return (...args) => _fetch(...args)\n}\n\nexport const looksLikeFetchResponse = (maybeResponse: unknown): maybeResponse is Response => {\n  return (\n    typeof maybeResponse === 'object' &&\n    maybeResponse !== null &&\n    'status' in maybeResponse &&\n    'ok' in maybeResponse &&\n    'json' in maybeResponse &&\n    typeof (maybeResponse as any).json === 'function'\n  )\n}\n\n// Storage helpers\nexport const setItemAsync = async (\n  storage: SupportedStorage,\n  key: string,\n  data: any\n): Promise<void> => {\n  await storage.setItem(key, JSON.stringify(data))\n}\n\nexport const getItemAsync = async (storage: SupportedStorage, key: string): Promise<unknown> => {\n  const value = await storage.getItem(key)\n\n  if (!value) {\n    return null\n  }\n\n  try {\n    return JSON.parse(value)\n  } catch {\n    return value\n  }\n}\n\nexport const removeItemAsync = async (storage: SupportedStorage, key: string): Promise<void> => {\n  await storage.removeItem(key)\n}\n\nexport const decodeBase64URL = (value: string): string => {\n  try {\n    // atob is present in all browsers and nodejs >= 16\n    // but if it is not it will throw a ReferenceError in which case we can try to use Buffer\n    // replace are here to convert the Base64-URL into Base64 which is what atob supports\n    // replace with //g regex acts like replaceAll\n    // Decoding base64 to UTF8 see https://stackoverflow.com/a/30106551/17622044\n    return decodeURIComponent(\n      atob(value.replace(/[-]/g, '+').replace(/[_]/g, '/'))\n        .split('')\n        .map((c) => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))\n        .join('')\n    )\n  } catch (e) {\n    if (e instanceof ReferenceError) {\n      // running on nodejs < 16\n      // Buffer supports Base64-URL transparently\n      return Buffer.from(value, 'base64').toString('utf-8')\n    } else {\n      throw e\n    }\n  }\n}\n\n/**\n * A deferred represents some asynchronous work that is not yet finished, which\n * may or may not culminate in a value.\n * Taken from: https://github.com/mike-north/types/blob/master/src/async.ts\n */\nexport class Deferred<T = any> {\n  public static promiseConstructor: PromiseConstructor = Promise\n\n  public readonly promise!: PromiseLike<T>\n\n  public readonly resolve!: (value?: T | PromiseLike<T>) => void\n\n  public readonly reject!: (reason?: any) => any\n\n  public constructor() {\n    // eslint-disable-next-line @typescript-eslint/no-extra-semi\n    ;(this as any).promise = new Deferred.promiseConstructor((res, rej) => {\n      // eslint-disable-next-line @typescript-eslint/no-extra-semi\n      ;(this as any).resolve = res\n      // eslint-disable-next-line @typescript-eslint/no-extra-semi\n      ;(this as any).reject = rej\n    })\n  }\n}\n// Taken from: https://stackoverflow.com/questions/38552003/how-to-decode-jwt-token-in-javascript-without-using-a-library\nexport function decodeJWTPayload(token: string) {\n  const parts = token.split('.')\n\n  if (parts.length !== 3) {\n    throw new Error('JWT is not valid: not a JWT structure')\n  }\n\n  const base64Url = parts[1]\n  return JSON.parse(decodeBase64URL(base64Url))\n}\n","export class AuthError extends Error {\n  protected __isAuthError = true\n\n  constructor(message: string) {\n    super(message)\n    this.name = 'AuthError'\n  }\n}\n\nexport function isAuthError(error: unknown): error is AuthError {\n  return typeof error === 'object' && error !== null && '__isAuthError' in error\n}\n\nexport class AuthApiError extends AuthError {\n  status: number\n\n  constructor(message: string, status: number) {\n    super(message)\n    this.name = 'AuthApiError'\n    this.status = status\n  }\n\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      status: this.status,\n    }\n  }\n}\n\nexport class AuthUnknownError extends AuthError {\n  originalError: unknown\n\n  constructor(message: string, originalError: unknown) {\n    super(message)\n    this.name = 'AuthUnknownError'\n    this.originalError = originalError\n  }\n}\n\nexport class CustomAuthError extends AuthError {\n  name: string\n  status: number\n  constructor(message: string, name: string, status: number) {\n    super(message)\n    this.name = name\n    this.status = status\n  }\n\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      status: this.status,\n    }\n  }\n}\n\nexport class AuthSessionMissingError extends CustomAuthError {\n  constructor() {\n    super('Auth session missing!', 'AuthSessionMissingError', 400)\n  }\n}\n\nexport class AuthInvalidCredentialsError extends CustomAuthError {\n  constructor(message: string) {\n    super(message, 'AuthInvalidCredentialsError', 400)\n  }\n}\n\nexport class AuthImplicitGrantRedirectError extends CustomAuthError {\n  details: { error: string; code: string } | null = null\n  constructor(message: string, details: { error: string; code: string } | null = null) {\n    super(message, 'AuthImplicitGrantRedirectError', 500)\n    this.details = details\n  }\n\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      status: this.status,\n      details: this.details,\n    }\n  }\n}\n\nexport class AuthRetryableFetchError extends CustomAuthError {\n  constructor(message: string, status: number) {\n    super(message, 'AuthRetryableFetchError', status)\n  }\n}\n","import { expiresAt, looksLikeFetchResponse } from './helpers'\nimport {\n  AuthResponse,\n  SSOResponse,\n  GenerateLinkProperties,\n  GenerateLinkResponse,\n  User,\n  UserResponse,\n} from './types'\nimport { AuthApiError, AuthRetryableFetchError, AuthUnknownError } from './errors'\n\nexport type Fetch = typeof fetch\n\nexport interface FetchOptions {\n  headers?: {\n    [key: string]: string\n  }\n  noResolveJson?: boolean\n}\n\nexport interface FetchParameters {\n  signal?: AbortSignal\n}\n\nexport type RequestMethodType = 'GET' | 'POST' | 'PUT' | 'DELETE'\n\nconst _getErrorMessage = (err: any): string =>\n  err.msg || err.message || err.error_description || err.error || JSON.stringify(err)\n\nconst handleError = async (error: unknown, reject: (reason?: any) => void) => {\n  const NETWORK_ERROR_CODES = [502, 503, 504]\n  if (!looksLikeFetchResponse(error)) {\n    reject(new AuthRetryableFetchError(_getErrorMessage(error), 0))\n  } else if (NETWORK_ERROR_CODES.includes(error.status)) {\n    // status in 500...599 range - server had an error, request might be retryed.\n    reject(new AuthRetryableFetchError(_getErrorMessage(error), error.status))\n  } else {\n    // got a response from server that is not in the 500...599 range - should not retry\n    error\n      .json()\n      .then((err) => {\n        reject(new AuthApiError(_getErrorMessage(err), error.status || 500))\n      })\n      .catch((e) => {\n        // not a valid json response\n        reject(new AuthUnknownError(_getErrorMessage(e), e))\n      })\n  }\n}\n\nconst _getRequestParams = (\n  method: RequestMethodType,\n  options?: FetchOptions,\n  parameters?: FetchParameters,\n  body?: object\n) => {\n  const params: { [k: string]: any } = { method, headers: options?.headers || {} }\n\n  if (method === 'GET') {\n    return params\n  }\n\n  params.headers = { 'Content-Type': 'application/json;charset=UTF-8', ...options?.headers }\n  params.body = JSON.stringify(body)\n  return { ...params, ...parameters }\n}\n\ninterface GotrueRequestOptions extends FetchOptions {\n  jwt?: string\n  redirectTo?: string\n  body?: object\n  query?: { [key: string]: string }\n  /**\n   * Function that transforms api response from gotrue into a desirable / standardised format\n   */\n  xform?: (data: any) => any\n}\n\nexport async function _request(\n  fetcher: Fetch,\n  method: RequestMethodType,\n  url: string,\n  options?: GotrueRequestOptions\n) {\n  const headers = options?.headers ?? {}\n  if (options?.jwt) {\n    headers['Authorization'] = `Bearer ${options.jwt}`\n  }\n  const qs = options?.query ?? {}\n  if (options?.redirectTo) {\n    qs['redirect_to'] = options.redirectTo\n  }\n  const queryString = Object.keys(qs).length ? '?' + new URLSearchParams(qs).toString() : ''\n  const data = await _handleRequest(\n    fetcher,\n    method,\n    url + queryString,\n    { headers, noResolveJson: options?.noResolveJson },\n    {},\n    options?.body\n  )\n  return options?.xform ? options?.xform(data) : { data: { ...data }, error: null }\n}\n\nasync function _handleRequest(\n  fetcher: Fetch,\n  method: RequestMethodType,\n  url: string,\n  options?: FetchOptions,\n  parameters?: FetchParameters,\n  body?: object\n): Promise<any> {\n  return new Promise((resolve, reject) => {\n    fetcher(url, _getRequestParams(method, options, parameters, body))\n      .then((result) => {\n        if (!result.ok) throw result\n        if (options?.noResolveJson) return result\n        return result.json()\n      })\n      .then((data) => resolve(data))\n      .catch((error) => handleError(error, reject))\n  })\n}\n\nexport function _sessionResponse(data: any): AuthResponse {\n  let session = null\n  if (hasSession(data)) {\n    session = { ...data }\n    session.expires_at = expiresAt(data.expires_in)\n  }\n  const user: User = data.user ?? (data as User)\n  return { data: { session, user }, error: null }\n}\n\nexport function _userResponse(data: any): UserResponse {\n  const user: User = data.user ?? (data as User)\n  return { data: { user }, error: null }\n}\n\nexport function _ssoResponse(data: any): SSOResponse {\n  return { data, error: null }\n}\n\nexport function _generateLinkResponse(data: any): GenerateLinkResponse {\n  const { action_link, email_otp, hashed_token, redirect_to, verification_type, ...rest } = data\n\n  const properties: GenerateLinkProperties = {\n    action_link,\n    email_otp,\n    hashed_token,\n    redirect_to,\n    verification_type,\n  }\n\n  const user: User = { ...rest }\n  return {\n    data: {\n      properties,\n      user,\n    },\n    error: null,\n  }\n}\n\n/**\n * hasSession checks if the response object contains a valid session\n * @param data A response object\n * @returns true if a session is in the response\n */\nfunction hasSession(data: any): boolean {\n  return data.access_token && data.refresh_token && data.expires_in\n}\n","import { Fetch, _generateLinkResponse, _request, _userResponse } from './lib/fetch'\nimport { resolveFetch } from './lib/helpers'\nimport {\n  AdminUserAttributes,\n  GenerateLinkParams,\n  GenerateLinkResponse,\n  User,\n  UserResponse,\n  GoTrueAdminMFAApi,\n  UpdatableFactorAttributes,\n  AuthMFAAdminDeleteFactorParams,\n  AuthMFAAdminDeleteFactorResponse,\n  AuthMFAAdminListFactorsParams,\n  AuthMFAAdminListFactorsResponse,\n} from './lib/types'\nimport { AuthError, isAuthError } from './lib/errors'\n\nexport default class GoTrueAdminApi {\n  /** Contains all MFA administration methods. */\n  mfa: GoTrueAdminMFAApi\n\n  protected url: string\n  protected headers: {\n    [key: string]: string\n  }\n  protected fetch: Fetch\n\n  constructor({\n    url = '',\n    headers = {},\n    fetch,\n  }: {\n    url: string\n    headers?: {\n      [key: string]: string\n    }\n    fetch?: Fetch\n  }) {\n    this.url = url\n    this.headers = headers\n    this.fetch = resolveFetch(fetch)\n    this.mfa = {\n      listFactors: this._listFactors.bind(this),\n      deleteFactor: this._deleteFactor.bind(this),\n    }\n  }\n\n  /**\n   * Removes a logged-in session.\n   * @param jwt A valid, logged-in JWT.\n   */\n  async signOut(jwt: string): Promise<{ data: null; error: AuthError | null }> {\n    try {\n      await _request(this.fetch, 'POST', `${this.url}/logout`, {\n        headers: this.headers,\n        jwt,\n        noResolveJson: true,\n      })\n      return { data: null, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Sends an invite link to an email address.\n   * @param email The email address of the user.\n   * @param options.redirectTo A URL or mobile deeplink to send the user to after they are confirmed.\n   * @param options.data Optional user metadata\n   */\n  async inviteUserByEmail(\n    email: string,\n    options: {\n      redirectTo?: string\n      data?: object\n    } = {}\n  ): Promise<UserResponse> {\n    try {\n      return await _request(this.fetch, 'POST', `${this.url}/invite`, {\n        body: { email, data: options.data },\n        headers: this.headers,\n        redirectTo: options.redirectTo,\n        xform: _userResponse,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Generates email links and OTPs to be sent via a custom email provider.\n   * @param email The user's email.\n   * @param options.password User password. For signup only.\n   * @param options.data Optional user metadata. For signup only.\n   * @param options.redirectTo The redirect url which should be appended to the generated link\n   */\n  async generateLink(params: GenerateLinkParams): Promise<GenerateLinkResponse> {\n    try {\n      const { options, ...rest } = params\n      const body: any = { ...rest, ...options }\n      if ('newEmail' in rest) {\n        // replace newEmail with new_email in request body\n        body.new_email = rest?.newEmail\n        delete body['newEmail']\n      }\n      return await _request(this.fetch, 'POST', `${this.url}/admin/generate_link`, {\n        body: body,\n        headers: this.headers,\n        xform: _generateLinkResponse,\n        redirectTo: options?.redirectTo,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return {\n          data: {\n            properties: null,\n            user: null,\n          },\n          error,\n        }\n      }\n      throw error\n    }\n  }\n\n  // User Admin API\n  /**\n   * Creates a new user.\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  async createUser(attributes: AdminUserAttributes): Promise<UserResponse> {\n    try {\n      return await _request(this.fetch, 'POST', `${this.url}/admin/users`, {\n        body: attributes,\n        headers: this.headers,\n        xform: _userResponse,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Get a list of users.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  async listUsers(): Promise<\n    { data: { users: User[] }; error: null } | { data: { users: [] }; error: AuthError }\n  > {\n    try {\n      const { data, error } = await _request(this.fetch, 'GET', `${this.url}/admin/users`, {\n        headers: this.headers,\n      })\n      if (error) throw error\n      return { data: { ...data }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { users: [] }, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Get user by id.\n   *\n   * @param uid The user's unique identifier\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  async getUserById(uid: string): Promise<UserResponse> {\n    try {\n      return await _request(this.fetch, 'GET', `${this.url}/admin/users/${uid}`, {\n        headers: this.headers,\n        xform: _userResponse,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Updates the user data.\n   *\n   * @param attributes The data you want to update.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  async updateUserById(uid: string, attributes: AdminUserAttributes): Promise<UserResponse> {\n    try {\n      return await _request(this.fetch, 'PUT', `${this.url}/admin/users/${uid}`, {\n        body: attributes,\n        headers: this.headers,\n        xform: _userResponse,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Delete a user. Requires a `service_role` key.\n   *\n   * @param id The user id you want to remove.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  async deleteUser(id: string): Promise<UserResponse> {\n    try {\n      return await _request(this.fetch, 'DELETE', `${this.url}/admin/users/${id}`, {\n        headers: this.headers,\n        xform: _userResponse,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  private async _listFactors(\n    params: AuthMFAAdminListFactorsParams\n  ): Promise<AuthMFAAdminListFactorsResponse> {\n    try {\n      const data = await _request(\n        this.fetch,\n        'GET',\n        `${this.url}/admin/users/${params.userId}/factors`,\n        {\n          headers: this.headers,\n        }\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  private async _deleteFactor(\n    params: AuthMFAAdminDeleteFactorParams\n  ): Promise<AuthMFAAdminDeleteFactorResponse> {\n    try {\n      const data = await _request(\n        this.fetch,\n        'DELETE',\n        `${this.url}/admin/users/${params.userId}/factors/${params.id}`,\n        {\n          headers: this.headers,\n        }\n      )\n\n      return { data, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n}\n","import { version } from './version'\nexport const GOTRUE_URL = 'http://localhost:9999'\nexport const STORAGE_KEY = 'supabase.auth.token'\nexport const AUDIENCE = ''\nexport const DEFAULT_HEADERS = { 'X-Client-Info': `gotrue-js/${version}` }\nexport const EXPIRY_MARGIN = 10 // in seconds\nexport const NETWORK_FAILURE = {\n  MAX_RETRIES: 10,\n  RETRY_INTERVAL: 2, // in deciseconds\n}\n","// Generated by genversion.\nexport const version = '2.3.0'\n","import { isBrowser } from './helpers'\nimport { SupportedStorage } from './types'\n\nconst localStorageAdapter: SupportedStorage = {\n  getItem: (key) => {\n    if (!isBrowser()) {\n      return null\n    }\n\n    return globalThis.localStorage.getItem(key)\n  },\n  setItem: (key, value) => {\n    if (!isBrowser()) {\n      return\n    }\n\n    globalThis.localStorage.setItem(key, value)\n  },\n  removeItem: (key) => {\n    if (!isBrowser()) {\n      return\n    }\n\n    globalThis.localStorage.removeItem(key)\n  },\n}\n\nexport default localStorageAdapter\n","/**\n * https://mathiasbynens.be/notes/globalthis\n */\nexport function polyfillGlobalThis() {\n  if (typeof globalThis === 'object') return\n  try {\n    Object.defineProperty(Object.prototype, '__magic__', {\n      get: function () {\n        return this\n      },\n      configurable: true,\n    })\n    // @ts-expect-error 'Allow access to magic'\n    __magic__.globalThis = __magic__\n    // @ts-expect-error 'Allow access to magic'\n    delete Object.prototype.__magic__\n  } catch (e) {\n    if (typeof self !== 'undefined') {\n      // @ts-expect-error 'Allow access to globals'\n      self.globalThis = self\n    }\n  }\n}\n","import GoTrueAdminApi from './GoTrueAdminApi'\nimport {\n  DEFAULT_HEADERS,\n  EXPIRY_MARGIN,\n  GOTRUE_URL,\n  NETWORK_FAILURE,\n  STORAGE_KEY,\n} from './lib/constants'\nimport {\n  AuthError,\n  AuthImplicitGrantRedirectError,\n  AuthInvalidCredentialsError,\n  AuthRetryableFetchError,\n  AuthSessionMissingError,\n  AuthUnknownError,\n  isAuthError,\n} from './lib/errors'\nimport { Fetch, _request, _sessionResponse, _userResponse, _ssoResponse } from './lib/fetch'\nimport {\n  Deferred,\n  getItemAsync,\n  getParameterByName,\n  isBrowser,\n  removeItemAsync,\n  resolveFetch,\n  setItemAsync,\n  uuid,\n  decodeJWTPayload,\n} from './lib/helpers'\nimport localStorageAdapter from './lib/local-storage'\nimport { polyfillGlobalThis } from './lib/polyfills'\nimport type {\n  AuthChangeEvent,\n  AuthResponse,\n  CallRefreshTokenResult,\n  GoTrueClientOptions,\n  InitializeResult,\n  OAuthResponse,\n  SSOResponse,\n  Provider,\n  Session,\n  SignInWithOAuthCredentials,\n  SignInWithPasswordCredentials,\n  SignInWithPasswordlessCredentials,\n  SignInWithSSO,\n  SignUpWithPasswordCredentials,\n  Subscription,\n  SupportedStorage,\n  User,\n  UserAttributes,\n  UserResponse,\n  VerifyOtpParams,\n  GoTrueMFAApi,\n  MFAEnrollParams,\n  AuthMFAEnrollResponse,\n  MFAChallengeParams,\n  AuthMFAChallengeResponse,\n  MFAUnenrollParams,\n  AuthMFAUnenrollResponse,\n  MFAVerifyParams,\n  AuthMFAVerifyResponse,\n  AuthMFAListFactorsResponse,\n  AMREntry,\n  AuthMFAGetAuthenticatorAssuranceLevelResponse,\n  AuthenticatorAssuranceLevels,\n  Factor,\n  MFAChallengeAndVerifyParams,\n} from './lib/types'\n\npolyfillGlobalThis() // Make \"globalThis\" available\n\nconst DEFAULT_OPTIONS: Omit<Required<GoTrueClientOptions>, 'fetch' | 'storage'> = {\n  url: GOTRUE_URL,\n  storageKey: STORAGE_KEY,\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  headers: DEFAULT_HEADERS,\n}\n\nexport default class GoTrueClient {\n  /**\n   * Namespace for the GoTrue admin methods.\n   * These methods should only be used in a trusted server-side environment.\n   */\n  admin: GoTrueAdminApi\n  /**\n   * Namespace for the MFA methods.\n   */\n  mfa: GoTrueMFAApi\n  /**\n   * The storage key used to identify the values saved in localStorage\n   */\n  protected storageKey: string\n\n  /**\n   * The session object for the currently logged in user. If null, it means there isn't a logged-in user.\n   * Only used if persistSession is false.\n   */\n  protected inMemorySession: Session | null\n\n  protected autoRefreshToken: boolean\n  protected persistSession: boolean\n  protected storage: SupportedStorage\n  protected stateChangeEmitters: Map<string, Subscription> = new Map()\n  protected refreshTokenTimer?: ReturnType<typeof setTimeout>\n  protected networkRetries = 0\n  protected refreshingDeferred: Deferred<CallRefreshTokenResult> | null = null\n  /**\n   * Keeps track of the async client initialization.\n   * When null or not yet resolved the auth state is `unknown`\n   * Once resolved the the auth state is known and it's save to call any further client methods.\n   * Keep extra care to never reject or throw uncaught errors\n   */\n  protected initializePromise: Promise<InitializeResult> | null = null\n  protected detectSessionInUrl = true\n  protected url: string\n  protected headers: {\n    [key: string]: string\n  }\n  protected fetch: Fetch\n\n  /**\n   * Create a new client for use in the browser.\n   */\n  constructor(options: GoTrueClientOptions) {\n    const settings = { ...DEFAULT_OPTIONS, ...options }\n    this.inMemorySession = null\n    this.storageKey = settings.storageKey\n    this.autoRefreshToken = settings.autoRefreshToken\n    this.persistSession = settings.persistSession\n    this.storage = settings.storage || localStorageAdapter\n    this.admin = new GoTrueAdminApi({\n      url: settings.url,\n      headers: settings.headers,\n      fetch: settings.fetch,\n    })\n\n    this.url = settings.url\n    this.headers = settings.headers\n    this.fetch = resolveFetch(settings.fetch)\n    this.detectSessionInUrl = settings.detectSessionInUrl\n\n    this.initialize()\n    this.mfa = {\n      verify: this._verify.bind(this),\n      enroll: this._enroll.bind(this),\n      unenroll: this._unenroll.bind(this),\n      challenge: this._challenge.bind(this),\n      listFactors: this._listFactors.bind(this),\n      challengeAndVerify: this._challengeAndVerify.bind(this),\n      getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this),\n    }\n  }\n\n  /**\n   * Initializes the client session either from the url or from storage.\n   * This method is automatically called when instantiating the client, but should also be called\n   * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).\n   */\n  initialize(): Promise<InitializeResult> {\n    if (!this.initializePromise) {\n      this.initializePromise = this._initialize()\n    }\n\n    return this.initializePromise\n  }\n\n  /**\n   * IMPORTANT:\n   * 1. Never throw in this method, as it is called from the constructor\n   * 2. Never return a session from this method as it would be cached over\n   *    the whole lifetime of the client\n   */\n  private async _initialize(): Promise<InitializeResult> {\n    if (this.initializePromise) {\n      return this.initializePromise\n    }\n\n    try {\n      if (this.detectSessionInUrl && this._isImplicitGrantFlow()) {\n        const { data, error } = await this._getSessionFromUrl()\n\n        if (error) {\n          // failed login attempt via url,\n          // remove old session as in verifyOtp, signUp and signInWith*\n          await this._removeSession()\n\n          return { error }\n        }\n\n        const { session, redirectType } = data\n\n        await this._saveSession(session)\n        this._notifyAllSubscribers('SIGNED_IN', session)\n        if (redirectType === 'recovery') {\n          this._notifyAllSubscribers('PASSWORD_RECOVERY', session)\n        }\n\n        return { error: null }\n      }\n\n      // no login attempt via callback url try to recover session from storage\n      await this._recoverAndRefresh()\n      return { error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { error }\n      }\n\n      return {\n        error: new AuthUnknownError('Unexpected error during initialization', error),\n      }\n    } finally {\n      this._handleVisibilityChange()\n    }\n  }\n\n  /**\n   * Creates a new user.\n   * @returns A logged-in session if the server has \"autoconfirm\" ON\n   * @returns A user if the server has \"autoconfirm\" OFF\n   */\n  async signUp(credentials: SignUpWithPasswordCredentials): Promise<AuthResponse> {\n    try {\n      await this._removeSession()\n\n      let res: AuthResponse\n      if ('email' in credentials) {\n        const { email, password, options } = credentials\n        res = await _request(this.fetch, 'POST', `${this.url}/signup`, {\n          headers: this.headers,\n          redirectTo: options?.emailRedirectTo,\n          body: {\n            email,\n            password,\n            data: options?.data ?? {},\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n          },\n          xform: _sessionResponse,\n        })\n      } else if ('phone' in credentials) {\n        const { phone, password, options } = credentials\n        res = await _request(this.fetch, 'POST', `${this.url}/signup`, {\n          headers: this.headers,\n          body: {\n            phone,\n            password,\n            data: options?.data ?? {},\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n          },\n          xform: _sessionResponse,\n        })\n      } else {\n        throw new AuthInvalidCredentialsError(\n          'You must provide either an email or phone number and a password'\n        )\n      }\n\n      const { data, error } = res\n\n      if (error || !data) {\n        return { data: { user: null, session: null }, error: error }\n      }\n\n      const session: Session | null = data.session\n      const user: User | null = data.user\n\n      if (data.session) {\n        await this._saveSession(data.session)\n        this._notifyAllSubscribers('SIGNED_IN', session)\n      }\n\n      return { data: { user, session }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Log in an existing user with an email and password or phone and password.\n   */\n  async signInWithPassword(credentials: SignInWithPasswordCredentials): Promise<AuthResponse> {\n    try {\n      await this._removeSession()\n\n      let res: AuthResponse\n      if ('email' in credentials) {\n        const { email, password, options } = credentials\n        res = await _request(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\n          headers: this.headers,\n          body: {\n            email,\n            password,\n            data: options?.data ?? {},\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n          },\n          xform: _sessionResponse,\n        })\n      } else if ('phone' in credentials) {\n        const { phone, password, options } = credentials\n        res = await _request(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\n          headers: this.headers,\n          body: {\n            phone,\n            password,\n            data: options?.data ?? {},\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n          },\n          xform: _sessionResponse,\n        })\n      } else {\n        throw new AuthInvalidCredentialsError(\n          'You must provide either an email or phone number and a password'\n        )\n      }\n      const { data, error } = res\n      if (error || !data) return { data: { user: null, session: null }, error }\n      if (data.session) {\n        await this._saveSession(data.session)\n        this._notifyAllSubscribers('SIGNED_IN', data.session)\n      }\n      return { data, error }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Log in an existing user via a third-party provider.\n   */\n  async signInWithOAuth(credentials: SignInWithOAuthCredentials): Promise<OAuthResponse> {\n    await this._removeSession()\n    return this._handleProviderSignIn(credentials.provider, {\n      redirectTo: credentials.options?.redirectTo,\n      scopes: credentials.options?.scopes,\n      queryParams: credentials.options?.queryParams,\n    })\n  }\n\n  /**\n   * Log in a user using magiclink or a one-time password (OTP).\n   * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.\n   * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.\n   * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.\n   */\n  async signInWithOtp(credentials: SignInWithPasswordlessCredentials): Promise<AuthResponse> {\n    try {\n      await this._removeSession()\n\n      if ('email' in credentials) {\n        const { email, options } = credentials\n        const { error } = await _request(this.fetch, 'POST', `${this.url}/otp`, {\n          headers: this.headers,\n          body: {\n            email,\n            data: options?.data ?? {},\n            create_user: options?.shouldCreateUser ?? true,\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n          },\n          redirectTo: options?.emailRedirectTo,\n        })\n        return { data: { user: null, session: null }, error }\n      }\n      if ('phone' in credentials) {\n        const { phone, options } = credentials\n        const { error } = await _request(this.fetch, 'POST', `${this.url}/otp`, {\n          headers: this.headers,\n          body: {\n            phone,\n            data: options?.data ?? {},\n            create_user: options?.shouldCreateUser ?? true,\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n          },\n        })\n        return { data: { user: null, session: null }, error }\n      }\n      throw new AuthInvalidCredentialsError('You must provide either an email or phone number.')\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Log in a user given a User supplied OTP received via mobile.\n   */\n  async verifyOtp(params: VerifyOtpParams): Promise<AuthResponse> {\n    try {\n      await this._removeSession()\n\n      const { data, error } = await _request(this.fetch, 'POST', `${this.url}/verify`, {\n        headers: this.headers,\n        body: {\n          ...params,\n          gotrue_meta_security: { captcha_token: params.options?.captchaToken },\n        },\n        redirectTo: params.options?.redirectTo,\n        xform: _sessionResponse,\n      })\n\n      if (error) {\n        throw error\n      }\n\n      if (!data) {\n        throw 'An error occurred on token verification.'\n      }\n\n      const session: Session | null = data.session\n      const user: User = data.user\n\n      if (session?.access_token) {\n        await this._saveSession(session as Session)\n        this._notifyAllSubscribers('SIGNED_IN', session)\n      }\n\n      return { data: { user, session }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Attempts a single-sign on using an enterprise Identity Provider. A\n   * successful SSO attempt will redirect the current page to the identity\n   * provider authorization page. The redirect URL is implementation and SSO\n   * protocol specific.\n   *\n   * You can use it by providing a SSO domain. Typically you can extract this\n   * domain by asking users for their email address. If this domain is\n   * registered on the Auth instance the redirect will use that organization's\n   * currently active SSO Identity Provider for the login.\n   *\n   * If you have built an organization-specific login page, you can use the\n   * organization's SSO Identity Provider UUID directly instead.\n   *\n   * This API is experimental and availability is conditional on correct\n   * settings on the Auth service.\n   *\n   * @experimental\n   */\n  async signInWithSSO(params: SignInWithSSO): Promise<SSOResponse> {\n    try {\n      await this._removeSession()\n\n      return await _request(this.fetch, 'POST', `${this.url}/sso`, {\n        body: {\n          ...('providerId' in params ? { provider_id: params.providerId } : null),\n          ...('domain' in params ? { domain: params.domain } : null),\n          redirect_to: params.options?.redirectTo ?? undefined,\n          ...(params?.options?.captchaToken\n            ? { gotrue_meta_security: { captcha_token: params.options.captchaToken } }\n            : null),\n          skip_http_redirect: true, // fetch does not handle redirects\n        },\n        headers: this.headers,\n        xform: _ssoResponse,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Returns the session, refreshing it if necessary.\n   * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.\n   */\n  async getSession(): Promise<\n    | {\n        data: {\n          session: Session\n        }\n        error: null\n      }\n    | {\n        data: {\n          session: null\n        }\n        error: AuthError\n      }\n    | {\n        data: {\n          session: null\n        }\n        error: null\n      }\n  > {\n    // make sure we've read the session from the url if there is one\n    // save to just await, as long we make sure _initialize() never throws\n    await this.initializePromise\n\n    let currentSession: Session | null = null\n\n    if (this.persistSession) {\n      const maybeSession = await getItemAsync(this.storage, this.storageKey)\n\n      if (maybeSession !== null) {\n        if (this._isValidSession(maybeSession)) {\n          currentSession = maybeSession\n        } else {\n          await this._removeSession()\n        }\n      }\n    } else {\n      currentSession = this.inMemorySession\n    }\n\n    if (!currentSession) {\n      return { data: { session: null }, error: null }\n    }\n\n    const hasExpired = currentSession.expires_at\n      ? currentSession.expires_at <= Date.now() / 1000\n      : false\n    if (!hasExpired) {\n      return { data: { session: currentSession }, error: null }\n    }\n\n    const { session, error } = await this._callRefreshToken(currentSession.refresh_token)\n    if (error) {\n      return { data: { session: null }, error }\n    }\n\n    return { data: { session }, error: null }\n  }\n\n  /**\n   * Gets the current user details if there is an existing session.\n   * @param jwt Takes in an optional access token jwt. If no jwt is provided, getUser() will attempt to get the jwt from the current session.\n   */\n  async getUser(jwt?: string): Promise<UserResponse> {\n    try {\n      if (!jwt) {\n        const { data, error } = await this.getSession()\n        if (error) {\n          throw error\n        }\n\n        // Default to Authorization header if there is no existing session\n        jwt = data.session?.access_token ?? undefined\n      }\n\n      return await _request(this.fetch, 'GET', `${this.url}/user`, {\n        headers: this.headers,\n        jwt: jwt,\n        xform: _userResponse,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Updates user data, if there is a logged in user.\n   */\n  async updateUser(attributes: UserAttributes): Promise<UserResponse> {\n    try {\n      const { data: sessionData, error: sessionError } = await this.getSession()\n      if (sessionError) {\n        throw sessionError\n      }\n      if (!sessionData.session) {\n        throw new AuthSessionMissingError()\n      }\n      const session: Session = sessionData.session\n      const { data, error: userError } = await _request(this.fetch, 'PUT', `${this.url}/user`, {\n        headers: this.headers,\n        body: attributes,\n        jwt: session.access_token,\n        xform: _userResponse,\n      })\n      if (userError) throw userError\n      session.user = data.user as User\n      await this._saveSession(session)\n      this._notifyAllSubscribers('USER_UPDATED', session)\n\n      return { data: { user: session.user }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Decodes a JWT (without performing any validation).\n   */\n  private _decodeJWT(jwt: string): {\n    exp?: number\n    aal?: AuthenticatorAssuranceLevels | null\n    amr?: AMREntry[] | null\n  } {\n    return decodeJWTPayload(jwt)\n  }\n\n  /**\n   * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.\n   * If the refresh token in the current session is invalid and the current session has expired, an error will be thrown.\n   * If the current session does not contain at expires_at field, setSession will use the exp claim defined in the access token.\n   * @param currentSession The current session that minimally contains an access token and refresh token.\n   */\n  async setSession(currentSession: {\n    access_token: string\n    refresh_token: string\n  }): Promise<AuthResponse> {\n    try {\n      const timeNow = Date.now() / 1000\n      let expiresAt = timeNow\n      let hasExpired = true\n      let session: Session | null = null\n      if (currentSession.access_token && currentSession.access_token.split('.')[1]) {\n        const payload = this._decodeJWT(currentSession.access_token)\n\n        if (payload.exp) {\n          expiresAt = payload.exp\n          hasExpired = expiresAt <= timeNow\n        }\n      }\n\n      if (hasExpired) {\n        if (!currentSession.refresh_token) {\n          throw new AuthSessionMissingError()\n        }\n        const { data, error } = await this._refreshAccessToken(currentSession.refresh_token)\n        if (error) {\n          return { data: { session: null, user: null }, error: error }\n        }\n\n        if (!data.session) {\n          return { data: { session: null, user: null }, error: null }\n        }\n        session = data.session\n      } else {\n        const { data, error } = await this.getUser(currentSession.access_token)\n        if (error) {\n          throw error\n        }\n        session = {\n          access_token: currentSession.access_token,\n          refresh_token: currentSession.refresh_token,\n          user: data.user,\n          token_type: 'bearer',\n          expires_in: expiresAt - timeNow,\n          expires_at: expiresAt,\n        }\n      }\n\n      await this._saveSession(session)\n      this._notifyAllSubscribers('TOKEN_REFRESHED', session)\n\n      return { data: { session, user: session.user }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { session: null, user: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Returns a new session, regardless of expiry status.\n   * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().\n   * If the current session's refresh token is invalid, an error will be thrown.\n   * @param currentSession The current session. If passed in, it must contain a refresh token.\n   */\n  async refreshSession(currentSession?: { refresh_token: string }): Promise<AuthResponse> {\n    try {\n      if (!currentSession) {\n        const { data, error } = await this.getSession()\n        if (error) {\n          throw error\n        }\n\n        currentSession = data.session ?? undefined\n      }\n\n      if (!currentSession?.refresh_token) {\n        throw new AuthSessionMissingError()\n      }\n\n      const { session, error } = await this._callRefreshToken(currentSession.refresh_token)\n      if (error) {\n        return { data: { user: null, session: null }, error: error }\n      }\n\n      if (!session) {\n        return { data: { user: null, session: null }, error: null }\n      }\n\n      return { data: { user: session.user, session }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Gets the session data from a URL string\n   */\n  private async _getSessionFromUrl(): Promise<\n    | {\n        data: { session: Session; redirectType: string | null }\n        error: null\n      }\n    | { data: { session: null; redirectType: null }; error: AuthError }\n  > {\n    try {\n      if (!isBrowser()) throw new AuthImplicitGrantRedirectError('No browser detected.')\n      if (!this._isImplicitGrantFlow()) {\n        throw new AuthImplicitGrantRedirectError('Not a valid implicit grant flow url.')\n      }\n\n      const error_description = getParameterByName('error_description')\n      if (error_description) {\n        const error_code = getParameterByName('error_code')\n        if (!error_code) throw new AuthImplicitGrantRedirectError('No error_code detected.')\n        const error = getParameterByName('error')\n        if (!error) throw new AuthImplicitGrantRedirectError('No error detected.')\n\n        throw new AuthImplicitGrantRedirectError(error_description, { error, code: error_code })\n      }\n\n      const provider_token = getParameterByName('provider_token')\n      const provider_refresh_token = getParameterByName('provider_refresh_token')\n      const access_token = getParameterByName('access_token')\n      if (!access_token) throw new AuthImplicitGrantRedirectError('No access_token detected.')\n      const expires_in = getParameterByName('expires_in')\n      if (!expires_in) throw new AuthImplicitGrantRedirectError('No expires_in detected.')\n      const refresh_token = getParameterByName('refresh_token')\n      if (!refresh_token) throw new AuthImplicitGrantRedirectError('No refresh_token detected.')\n      const token_type = getParameterByName('token_type')\n      if (!token_type) throw new AuthImplicitGrantRedirectError('No token_type detected.')\n\n      const timeNow = Math.round(Date.now() / 1000)\n      const expires_at = timeNow + parseInt(expires_in)\n\n      const { data, error } = await this.getUser(access_token)\n      if (error) throw error\n      const user: User = data.user\n      const session: Session = {\n        provider_token,\n        provider_refresh_token,\n        access_token,\n        expires_in: parseInt(expires_in),\n        expires_at,\n        refresh_token,\n        token_type,\n        user,\n      }\n      const redirectType = getParameterByName('type')\n\n      // Remove tokens from URL\n      window.location.hash = ''\n\n      return { data: { session, redirectType }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { session: null, redirectType: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)\n   */\n  private _isImplicitGrantFlow(): boolean {\n    return (\n      isBrowser() &&\n      (Boolean(getParameterByName('access_token')) ||\n        Boolean(getParameterByName('error_description')))\n    )\n  }\n\n  /**\n   * Inside a browser context, `signOut()` will remove the logged in user from the browser session\n   * and log them out - removing all items from localstorage and then trigger a `\"SIGNED_OUT\"` event.\n   *\n   * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.\n   * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.\n   */\n  async signOut(): Promise<{ error: AuthError | null }> {\n    const { data, error: sessionError } = await this.getSession()\n    if (sessionError) {\n      return { error: sessionError }\n    }\n    const accessToken = data.session?.access_token\n    if (accessToken) {\n      const { error } = await this.admin.signOut(accessToken)\n      if (error) return { error }\n    }\n    await this._removeSession()\n    this._notifyAllSubscribers('SIGNED_OUT', null)\n    return { error: null }\n  }\n\n  /**\n   * Receive a notification every time an auth event happens.\n   * @param callback A callback function to be invoked when an auth event happens.\n   */\n  onAuthStateChange(callback: (event: AuthChangeEvent, session: Session | null) => void): {\n    data: { subscription: Subscription }\n  } {\n    const id: string = uuid()\n    const subscription: Subscription = {\n      id,\n      callback,\n      unsubscribe: () => {\n        this.stateChangeEmitters.delete(id)\n      },\n    }\n\n    this.stateChangeEmitters.set(id, subscription)\n\n    return { data: { subscription } }\n  }\n\n  /**\n   * Sends a password reset request to an email address.\n   * @param email The email address of the user.\n   * @param options.redirectTo The URL to send the user to after they click the password reset link.\n   * @param options.captchaToken Verification token received when the user completes the captcha on the site.\n   */\n  async resetPasswordForEmail(\n    email: string,\n    options: {\n      redirectTo?: string\n      captchaToken?: string\n    } = {}\n  ): Promise<\n    | {\n        data: {}\n        error: null\n      }\n    | { data: null; error: AuthError }\n  > {\n    try {\n      return await _request(this.fetch, 'POST', `${this.url}/recover`, {\n        body: { email, gotrue_meta_security: { captcha_token: options.captchaToken } },\n        headers: this.headers,\n        redirectTo: options.redirectTo,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Generates a new JWT.\n   * @param refreshToken A valid refresh token that was returned on login.\n   */\n  private async _refreshAccessToken(refreshToken: string): Promise<AuthResponse> {\n    try {\n      return await _request(this.fetch, 'POST', `${this.url}/token?grant_type=refresh_token`, {\n        body: { refresh_token: refreshToken },\n        headers: this.headers,\n        xform: _sessionResponse,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { session: null, user: null }, error }\n      }\n      throw error\n    }\n  }\n\n  private _isValidSession(maybeSession: unknown): maybeSession is Session {\n    const isValidSession =\n      typeof maybeSession === 'object' &&\n      maybeSession !== null &&\n      'access_token' in maybeSession &&\n      'refresh_token' in maybeSession &&\n      'expires_at' in maybeSession\n\n    return isValidSession\n  }\n\n  private _handleProviderSignIn(\n    provider: Provider,\n    options: {\n      redirectTo?: string\n      scopes?: string\n      queryParams?: { [key: string]: string }\n    } = {}\n  ) {\n    const url: string = this._getUrlForProvider(provider, {\n      redirectTo: options.redirectTo,\n      scopes: options.scopes,\n      queryParams: options.queryParams,\n    })\n    // try to open on the browser\n    if (isBrowser()) {\n      window.location.href = url\n    }\n    return { data: { provider, url }, error: null }\n  }\n\n  /**\n   * Recovers the session from LocalStorage and refreshes\n   * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n   */\n  private async _recoverAndRefresh() {\n    try {\n      const currentSession = await getItemAsync(this.storage, this.storageKey)\n      if (!this._isValidSession(currentSession)) {\n        if (currentSession !== null) {\n          await this._removeSession()\n        }\n\n        return\n      }\n\n      const timeNow = Math.round(Date.now() / 1000)\n\n      if ((currentSession.expires_at ?? Infinity) < timeNow + EXPIRY_MARGIN) {\n        if (this.autoRefreshToken && currentSession.refresh_token) {\n          this.networkRetries++\n          const { error } = await this._callRefreshToken(currentSession.refresh_token)\n          if (error) {\n            console.log(error.message)\n            if (\n              error instanceof AuthRetryableFetchError &&\n              this.networkRetries < NETWORK_FAILURE.MAX_RETRIES\n            ) {\n              if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer)\n              this.refreshTokenTimer = setTimeout(\n                () => this._recoverAndRefresh(),\n                NETWORK_FAILURE.RETRY_INTERVAL ** this.networkRetries * 100 // exponential backoff\n              )\n              return\n            }\n            await this._removeSession()\n          }\n          this.networkRetries = 0\n        } else {\n          await this._removeSession()\n        }\n      } else {\n        if (this.persistSession) {\n          await this._saveSession(currentSession)\n        }\n        this._notifyAllSubscribers('SIGNED_IN', currentSession)\n      }\n    } catch (err) {\n      console.error(err)\n      return\n    }\n  }\n\n  private async _callRefreshToken(refreshToken: string): Promise<CallRefreshTokenResult> {\n    // refreshing is already in progress\n    if (this.refreshingDeferred) {\n      return this.refreshingDeferred.promise\n    }\n\n    try {\n      this.refreshingDeferred = new Deferred<CallRefreshTokenResult>()\n\n      if (!refreshToken) {\n        throw new AuthSessionMissingError()\n      }\n      const { data, error } = await this._refreshAccessToken(refreshToken)\n      if (error) throw error\n      if (!data.session) throw new AuthSessionMissingError()\n\n      await this._saveSession(data.session)\n      this._notifyAllSubscribers('TOKEN_REFRESHED', data.session)\n\n      const result = { session: data.session, error: null }\n\n      this.refreshingDeferred.resolve(result)\n\n      return result\n    } catch (error) {\n      if (isAuthError(error)) {\n        const result = { session: null, error }\n\n        this.refreshingDeferred?.resolve(result)\n\n        return result\n      }\n\n      this.refreshingDeferred?.reject(error)\n      throw error\n    } finally {\n      this.refreshingDeferred = null\n    }\n  }\n\n  private _notifyAllSubscribers(event: AuthChangeEvent, session: Session | null) {\n    this.stateChangeEmitters.forEach((x) => x.callback(event, session))\n  }\n\n  /**\n   * set currentSession and currentUser\n   * process to _startAutoRefreshToken if possible\n   */\n  private async _saveSession(session: Session) {\n    if (!this.persistSession) {\n      this.inMemorySession = session\n    }\n\n    const expiresAt = session.expires_at\n    if (expiresAt) {\n      const timeNow = Math.round(Date.now() / 1000)\n      const expiresIn = expiresAt - timeNow\n      const refreshDurationBeforeExpires = expiresIn > EXPIRY_MARGIN ? EXPIRY_MARGIN : 0.5\n      this._startAutoRefreshToken((expiresIn - refreshDurationBeforeExpires) * 1000)\n    }\n\n    if (this.persistSession && session.expires_at) {\n      await this._persistSession(session)\n    }\n  }\n\n  private _persistSession(currentSession: Session) {\n    return setItemAsync(this.storage, this.storageKey, currentSession)\n  }\n\n  private async _removeSession() {\n    if (this.persistSession) {\n      await removeItemAsync(this.storage, this.storageKey)\n    } else {\n      this.inMemorySession = null\n    }\n\n    if (this.refreshTokenTimer) {\n      clearTimeout(this.refreshTokenTimer)\n    }\n  }\n\n  /**\n   * Clear and re-create refresh token timer\n   * @param value time intervals in milliseconds.\n   * @param session The current session.\n   */\n  private _startAutoRefreshToken(value: number) {\n    if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer)\n    if (value <= 0 || !this.autoRefreshToken) return\n\n    this.refreshTokenTimer = setTimeout(async () => {\n      this.networkRetries++\n      const {\n        data: { session },\n        error: sessionError,\n      } = await this.getSession()\n      if (!sessionError && session) {\n        const { error } = await this._callRefreshToken(session.refresh_token)\n        if (!error) this.networkRetries = 0\n        if (\n          error instanceof AuthRetryableFetchError &&\n          this.networkRetries < NETWORK_FAILURE.MAX_RETRIES\n        )\n          this._startAutoRefreshToken(NETWORK_FAILURE.RETRY_INTERVAL ** this.networkRetries * 100) // exponential backoff\n      }\n    }, value)\n    if (typeof this.refreshTokenTimer.unref === 'function') this.refreshTokenTimer.unref()\n  }\n\n  private _handleVisibilityChange() {\n    if (!isBrowser() || !window?.addEventListener) {\n      return false\n    }\n\n    try {\n      window?.addEventListener('visibilitychange', async () => {\n        if (document.visibilityState === 'visible') {\n          await this.initializePromise\n          await this._recoverAndRefresh()\n        }\n      })\n    } catch (error) {\n      console.error('_handleVisibilityChange', error)\n    }\n  }\n\n  /**\n   * Generates the relevant login URL for a third-party provider.\n   * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param options.scopes A space-separated list of scopes granted to the OAuth application.\n   * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.\n   */\n  private _getUrlForProvider(\n    provider: Provider,\n    options: {\n      redirectTo?: string\n      scopes?: string\n      queryParams?: { [key: string]: string }\n    }\n  ) {\n    const urlParams: string[] = [`provider=${encodeURIComponent(provider)}`]\n    if (options?.redirectTo) {\n      urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`)\n    }\n    if (options?.scopes) {\n      urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`)\n    }\n    if (options?.queryParams) {\n      const query = new URLSearchParams(options.queryParams)\n      urlParams.push(query.toString())\n    }\n    return `${this.url}/authorize?${urlParams.join('&')}`\n  }\n\n  private async _unenroll(params: MFAUnenrollParams): Promise<AuthMFAUnenrollResponse> {\n    const { data: sessionData, error: sessionError } = await this.getSession()\n    if (sessionError) {\n      return { data: null, error: sessionError }\n    }\n\n    return await _request(this.fetch, 'DELETE', `${this.url}/factors/${params.factorId}`, {\n      headers: this.headers,\n      jwt: sessionData?.session?.access_token,\n    })\n  }\n\n  /**\n   * Deletes a registered factor from GoTrue\n   * @param friendlyName Human readable name assigned to a device\n   * @param factorType device which we're validating against. Can only be TOTP for now.\n   * @param issuer domain which the user is enrolling with\n   */\n  private async _enroll(params: MFAEnrollParams): Promise<AuthMFAEnrollResponse> {\n    const { data: sessionData, error: sessionError } = await this.getSession()\n    if (sessionError) {\n      return { data: null, error: sessionError }\n    }\n\n    const { data, error } = await _request(this.fetch, 'POST', `${this.url}/factors`, {\n      body: {\n        friendly_name: params.friendlyName,\n        factor_type: params.factorType,\n        issuer: params.issuer,\n      },\n      headers: this.headers,\n      jwt: sessionData?.session?.access_token,\n    })\n\n    if (error) {\n      return { data: null, error }\n    }\n\n    if (data?.totp?.qr_code) {\n      data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`\n    }\n\n    return { data, error: null }\n  }\n\n  /**\n   * Validates a device as part of the enrollment step.\n   * @param factorID System assigned identifier for authenticator device as returned by enroll\n   * @param code Code Generated by an authenticator device\n   */\n  private async _verify(params: MFAVerifyParams): Promise<AuthMFAVerifyResponse> {\n    const { data: sessionData, error: sessionError } = await this.getSession()\n    if (sessionError) {\n      return { data: null, error: sessionError }\n    }\n\n    const { data, error } = await _request(\n      this.fetch,\n      'POST',\n      `${this.url}/factors/${params.factorId}/verify`,\n      {\n        body: { code: params.code, challenge_id: params.challengeId },\n        headers: this.headers,\n        jwt: sessionData?.session?.access_token,\n      }\n    )\n    if (error) {\n      return { data: null, error }\n    }\n\n    await this._saveSession({\n      expires_at: Math.round(Date.now() / 1000) + data.expires_in,\n      ...data,\n    })\n    this._notifyAllSubscribers('MFA_CHALLENGE_VERIFIED', data)\n\n    return { data, error }\n  }\n\n  /**\n   * Creates a challenge which a user can verify against\n   * @param factorID System assigned identifier for authenticator device as returned by enroll\n   */\n  private async _challenge(params: MFAChallengeParams): Promise<AuthMFAChallengeResponse> {\n    const { data: sessionData, error: sessionError } = await this.getSession()\n    if (sessionError) {\n      return { data: null, error: sessionError }\n    }\n\n    return await _request(this.fetch, 'POST', `${this.url}/factors/${params.factorId}/challenge`, {\n      headers: this.headers,\n      jwt: sessionData?.session?.access_token,\n    })\n  }\n  private async _challengeAndVerify(\n    params: MFAChallengeAndVerifyParams\n  ): Promise<AuthMFAVerifyResponse> {\n    const { data: challengeData, error: challengeError } = await this._challenge({\n      factorId: params.factorId,\n    })\n    if (challengeError) {\n      return { data: null, error: challengeError }\n    }\n    return await this._verify({\n      factorId: params.factorId,\n      challengeId: challengeData.id,\n      code: params.code,\n    })\n  }\n\n  /**\n   * Displays all devices for a given user\n   */\n  private async _listFactors(): Promise<AuthMFAListFactorsResponse> {\n    const {\n      data: { user },\n      error: userError,\n    } = await this.getUser()\n    if (userError) {\n      return { data: null, error: userError }\n    }\n\n    const factors = user?.factors || []\n    const totp = factors.filter(\n      (factor) => factor.factor_type === 'totp' && factor.status === 'verified'\n    )\n\n    return {\n      data: {\n        all: factors,\n        totp,\n      },\n      error: null,\n    }\n  }\n\n  private async _getAuthenticatorAssuranceLevel(): Promise<AuthMFAGetAuthenticatorAssuranceLevelResponse> {\n    const {\n      data: { session },\n      error: sessionError,\n    } = await this.getSession()\n    if (sessionError) {\n      return { data: null, error: sessionError }\n    }\n    if (!session) {\n      return {\n        data: { currentLevel: null, nextLevel: null, currentAuthenticationMethods: [] },\n        error: null,\n      }\n    }\n\n    const payload = this._decodeJWT(session.access_token)\n\n    let currentLevel: AuthenticatorAssuranceLevels | null = null\n\n    if (payload.aal) {\n      currentLevel = payload.aal\n    }\n\n    let nextLevel: AuthenticatorAssuranceLevels | null = currentLevel\n\n    const verifiedFactors =\n      session.user.factors?.filter((factor: Factor) => factor.status === 'verified') ?? []\n\n    if (verifiedFactors.length > 0) {\n      nextLevel = 'aal2'\n    }\n\n    const currentAuthenticationMethods = payload.amr || []\n\n    return { data: { currentLevel, nextLevel, currentAuthenticationMethods }, error: null }\n  }\n}\n","import { GoTrueClient } from '@supabase/gotrue-js'\nimport { SupabaseAuthClientOptions } from './types'\n\nexport class SupabaseAuthClient extends GoTrueClient {\n  constructor(options: SupabaseAuthClientOptions) {\n    super(options)\n  }\n}\n","import { FunctionsClient } from '@supabase/functions-js'\nimport { AuthChangeEvent } from '@supabase/gotrue-js'\nimport {\n  PostgrestClient,\n  PostgrestFilterBuilder,\n  PostgrestQueryBuilder,\n} from '@supabase/postgrest-js'\nimport {\n  RealtimeChannel,\n  RealtimeChannelOptions,\n  RealtimeClient,\n  RealtimeClientOptions,\n} from '@supabase/realtime-js'\nimport { StorageClient as SupabaseStorageClient } from '@supabase/storage-js'\nimport { DEFAULT_HEADERS } from './lib/constants'\nimport { fetchWithAuth } from './lib/fetch'\nimport { stripTrailingSlash, applySettingDefaults } from './lib/helpers'\nimport { SupabaseAuthClient } from './lib/SupabaseAuthClient'\nimport { Fetch, GenericSchema, SupabaseClientOptions, SupabaseAuthClientOptions } from './lib/types'\n\nconst DEFAULT_GLOBAL_OPTIONS = {\n  headers: DEFAULT_HEADERS,\n}\n\nconst DEFAULT_DB_OPTIONS = {\n  schema: 'public',\n}\n\nconst DEFAULT_AUTH_OPTIONS: SupabaseAuthClientOptions = {\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n}\n\nconst DEFAULT_REALTIME_OPTIONS: RealtimeClientOptions = {}\n\n/**\n * Supabase Client.\n *\n * An isomorphic Javascript client for interacting with Postgres.\n */\nexport default class SupabaseClient<\n  Database = any,\n  SchemaName extends string & keyof Database = 'public' extends keyof Database\n    ? 'public'\n    : string & keyof Database,\n  Schema extends GenericSchema = Database[SchemaName] extends GenericSchema\n    ? Database[SchemaName]\n    : any\n> {\n  /**\n   * Supabase Auth allows you to create and manage user sessions for access to data that is secured by access policies.\n   */\n  auth: SupabaseAuthClient\n\n  protected realtimeUrl: string\n  protected authUrl: string\n  protected storageUrl: string\n  protected functionsUrl: string\n  protected realtime: RealtimeClient\n  protected rest: PostgrestClient<Database, SchemaName>\n  protected storageKey: string\n  protected fetch?: Fetch\n  protected changedAccessToken: string | undefined\n\n  protected headers: {\n    [key: string]: string\n  }\n\n  /**\n   * Create a new client for use in the browser.\n   * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.\n   * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.\n   * @param options.db.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.\n   * @param options.auth.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n   * @param options.auth.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n   * @param options.auth.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n   * @param options.realtime Options passed along to realtime-js constructor.\n   * @param options.global.fetch A custom fetch implementation.\n   * @param options.global.headers Any additional headers to send with each network request.\n   */\n  constructor(\n    protected supabaseUrl: string,\n    protected supabaseKey: string,\n    options?: SupabaseClientOptions<SchemaName>\n  ) {\n    if (!supabaseUrl) throw new Error('supabaseUrl is required.')\n    if (!supabaseKey) throw new Error('supabaseKey is required.')\n\n    const _supabaseUrl = stripTrailingSlash(supabaseUrl)\n\n    this.realtimeUrl = `${_supabaseUrl}/realtime/v1`.replace(/^http/i, 'ws')\n    this.authUrl = `${_supabaseUrl}/auth/v1`\n    this.storageUrl = `${_supabaseUrl}/storage/v1`\n\n    const isPlatform = _supabaseUrl.match(/(supabase\\.co)|(supabase\\.in)/)\n    if (isPlatform) {\n      const urlParts = _supabaseUrl.split('.')\n      this.functionsUrl = `${urlParts[0]}.functions.${urlParts[1]}.${urlParts[2]}`\n    } else {\n      this.functionsUrl = `${_supabaseUrl}/functions/v1`\n    }\n    // default storage key uses the supabase project ref as a namespace\n    const defaultStorageKey = `sb-${new URL(this.authUrl).hostname.split('.')[0]}-auth-token`\n    const DEFAULTS = {\n      db: DEFAULT_DB_OPTIONS,\n      realtime: DEFAULT_REALTIME_OPTIONS,\n      auth: { ...DEFAULT_AUTH_OPTIONS, storageKey: defaultStorageKey },\n      global: DEFAULT_GLOBAL_OPTIONS,\n    }\n\n    const settings = applySettingDefaults(options ?? {}, DEFAULTS)\n\n    this.storageKey = settings.auth?.storageKey ?? ''\n    this.headers = settings.global?.headers ?? {}\n\n    this.auth = this._initSupabaseAuthClient(\n      settings.auth ?? {},\n      this.headers,\n      settings.global?.fetch\n    )\n    this.fetch = fetchWithAuth(supabaseKey, this._getAccessToken.bind(this), settings.global?.fetch)\n\n    this.realtime = this._initRealtimeClient({ headers: this.headers, ...settings.realtime })\n    this.rest = new PostgrestClient(`${_supabaseUrl}/rest/v1`, {\n      headers: this.headers,\n      schema: settings.db?.schema,\n      fetch: this.fetch,\n    })\n\n    this._listenForAuthEvents()\n  }\n\n  /**\n   * Supabase Functions allows you to deploy and invoke edge functions.\n   */\n  get functions() {\n    return new FunctionsClient(this.functionsUrl, {\n      headers: this.headers,\n      customFetch: this.fetch,\n    })\n  }\n\n  /**\n   * Supabase Storage allows you to manage user-generated content, such as photos or videos.\n   */\n  get storage() {\n    return new SupabaseStorageClient(this.storageUrl, this.headers, this.fetch)\n  }\n\n  /**\n   * Perform a table operation.\n   *\n   * @param table The table name to operate on.\n   */\n  from<\n    TableName extends string & keyof Schema['Tables'],\n    Table extends Schema['Tables'][TableName]\n  >(relation: TableName): PostgrestQueryBuilder<Schema, Table>\n  from<ViewName extends string & keyof Schema['Views'], View extends Schema['Views'][ViewName]>(\n    relation: ViewName\n  ): PostgrestQueryBuilder<Schema, View>\n  from(relation: string): PostgrestQueryBuilder<Schema, any>\n  from(relation: string): PostgrestQueryBuilder<Schema, any> {\n    return this.rest.from(relation)\n  }\n\n  /**\n   * Perform a function call.\n   *\n   * @param fn  The function name to call.\n   * @param args  The parameters to pass to the function call.\n   * @param options.head   When set to true, no data will be returned.\n   * @param options.count  Count algorithm to use to count rows in a table.\n   *\n   */\n  rpc<\n    FunctionName extends string & keyof Schema['Functions'],\n    Function_ extends Schema['Functions'][FunctionName]\n  >(\n    fn: FunctionName,\n    args: Function_['Args'] = {},\n    options?: {\n      head?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n    }\n  ): PostgrestFilterBuilder<\n    Schema,\n    Function_['Returns'] extends any[]\n      ? Function_['Returns'][number] extends Record<string, unknown>\n        ? Function_['Returns'][number]\n        : never\n      : never,\n    Function_['Returns']\n  > {\n    return this.rest.rpc(fn, args, options)\n  }\n\n  /**\n   * Creates a Realtime channel with Broadcast, Presence, and Postgres Changes.\n   *\n   * @param {string} name - The name of the Realtime channel.\n   * @param {Object} opts - The options to pass to the Realtime channel.\n   *\n   */\n  channel(name: string, opts: RealtimeChannelOptions = { config: {} }): RealtimeChannel {\n    return this.realtime.channel(name, opts)\n  }\n\n  /**\n   * Returns all Realtime channels.\n   */\n  getChannels(): RealtimeChannel[] {\n    return this.realtime.getChannels()\n  }\n\n  /**\n   * Unsubscribes and removes Realtime channel from Realtime client.\n   *\n   * @param {RealtimeChannel} channel - The name of the Realtime channel.\n   *\n   */\n  removeChannel(channel: RealtimeChannel): Promise<'ok' | 'timed out' | 'error'> {\n    return this.realtime.removeChannel(channel)\n  }\n\n  /**\n   * Unsubscribes and removes all Realtime channels from Realtime client.\n   */\n  removeAllChannels(): Promise<('ok' | 'timed out' | 'error')[]> {\n    return this.realtime.removeAllChannels()\n  }\n\n  private async _getAccessToken() {\n    const { data } = await this.auth.getSession()\n\n    return data.session?.access_token ?? null\n  }\n\n  private _initSupabaseAuthClient(\n    {\n      autoRefreshToken,\n      persistSession,\n      detectSessionInUrl,\n      storage,\n      storageKey,\n    }: SupabaseAuthClientOptions,\n    headers?: Record<string, string>,\n    fetch?: Fetch\n  ) {\n    const authHeaders = {\n      Authorization: `Bearer ${this.supabaseKey}`,\n      apikey: `${this.supabaseKey}`,\n    }\n    return new SupabaseAuthClient({\n      url: this.authUrl,\n      headers: { ...authHeaders, ...headers },\n      storageKey: storageKey,\n      autoRefreshToken,\n      persistSession,\n      detectSessionInUrl,\n      storage,\n      fetch,\n    })\n  }\n\n  private _initRealtimeClient(options: RealtimeClientOptions) {\n    return new RealtimeClient(this.realtimeUrl, {\n      ...options,\n      params: { ...{ apikey: this.supabaseKey }, ...options?.params },\n    })\n  }\n\n  private _listenForAuthEvents() {\n    let data = this.auth.onAuthStateChange((event, session) => {\n      this._handleTokenChanged(event, session?.access_token, 'CLIENT')\n    })\n    return data\n  }\n\n  private _handleTokenChanged(\n    event: AuthChangeEvent,\n    token: string | undefined,\n    source: 'CLIENT' | 'STORAGE'\n  ) {\n    if (\n      (event === 'TOKEN_REFRESHED' || event === 'SIGNED_IN') &&\n      this.changedAccessToken !== token\n    ) {\n      // Token has changed\n      this.realtime.setAuth(token ?? null)\n\n      this.changedAccessToken = token\n    } else if (event === 'SIGNED_OUT' || event === 'USER_DELETED') {\n      // Token is removed\n      this.realtime.setAuth(this.supabaseKey)\n      if (source == 'STORAGE') this.auth.signOut()\n    }\n  }\n}\n","// helpers.ts\nimport { SupabaseClientOptions } from './types'\n\nexport function uuid() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    var r = (Math.random() * 16) | 0,\n      v = c == 'x' ? r : (r & 0x3) | 0x8\n    return v.toString(16)\n  })\n}\n\nexport function stripTrailingSlash(url: string): string {\n  return url.replace(/\\/$/, '')\n}\n\nexport const isBrowser = () => typeof window !== 'undefined'\n\nexport function applySettingDefaults<\n  Database = any,\n  SchemaName extends string & keyof Database = 'public' extends keyof Database\n    ? 'public'\n    : string & keyof Database\n>(\n  options: SupabaseClientOptions<SchemaName>,\n  defaults: SupabaseClientOptions<any>\n): SupabaseClientOptions<SchemaName> {\n  const {\n    db: dbOptions,\n    auth: authOptions,\n    realtime: realtimeOptions,\n    global: globalOptions,\n  } = options\n  const {\n    db: DEFAULT_DB_OPTIONS,\n    auth: DEFAULT_AUTH_OPTIONS,\n    realtime: DEFAULT_REALTIME_OPTIONS,\n    global: DEFAULT_GLOBAL_OPTIONS,\n  } = defaults\n\n  return {\n    db: {\n      ...DEFAULT_DB_OPTIONS,\n      ...dbOptions,\n    },\n    auth: {\n      ...DEFAULT_AUTH_OPTIONS,\n      ...authOptions,\n    },\n    realtime: {\n      ...DEFAULT_REALTIME_OPTIONS,\n      ...realtimeOptions,\n    },\n    global: {\n      ...DEFAULT_GLOBAL_OPTIONS,\n      ...globalOptions,\n    },\n  }\n}\n","import SupabaseClient from './SupabaseClient'\nimport type { GenericSchema, SupabaseClientOptions } from './lib/types'\n\nexport * from '@supabase/gotrue-js'\nexport type { User as AuthUser, Session as AuthSession } from '@supabase/gotrue-js'\nexport type {\n  PostgrestResponse,\n  PostgrestSingleResponse,\n  PostgrestMaybeSingleResponse,\n  PostgrestError,\n} from '@supabase/postgrest-js'\nexport {\n  FunctionsHttpError,\n  FunctionsFetchError,\n  FunctionsRelayError,\n  FunctionsError,\n} from '@supabase/functions-js'\nexport * from '@supabase/realtime-js'\nexport { default as SupabaseClient } from './SupabaseClient'\nexport type { SupabaseClientOptions } from './lib/types'\n\n/**\n * Creates a new Supabase Client.\n */\nexport const createClient = <\n  Database = any,\n  SchemaName extends string & keyof Database = 'public' extends keyof Database\n    ? 'public'\n    : string & keyof Database,\n  Schema extends GenericSchema = Database[SchemaName] extends GenericSchema\n    ? Database[SchemaName]\n    : any\n>(\n  supabaseUrl: string,\n  supabaseKey: string,\n  options?: SupabaseClientOptions<SchemaName>\n): SupabaseClient<Database, SchemaName, Schema> => {\n  return new SupabaseClient(supabaseUrl, supabaseKey, options)\n}\n","var global = typeof self !== 'undefined' ? self : this;\nvar __self__ = (function () {\nfunction F() {\nthis.fetch = false;\nthis.DOMException = global.DOMException\n}\nF.prototype = global;\nreturn new F();\n})();\n(function(self) {\n\nvar irrelevant = (function (exports) {\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob:\n      'FileReader' in self &&\n      'Blob' in self &&\n      (function() {\n        try {\n          new Blob();\n          return true\n        } catch (e) {\n          return false\n        }\n      })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  };\n\n  function isDataView(obj) {\n    return obj && DataView.prototype.isPrototypeOf(obj)\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ];\n\n    var isArrayBufferView =\n      ArrayBuffer.isView ||\n      function(obj) {\n        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n      };\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name);\n    }\n    if (/[^a-z0-9\\-#$%&'*+.^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value);\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift();\n        return {done: value === undefined, value: value}\n      }\n    };\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      };\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {};\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value);\n      }, this);\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1]);\n      }, this);\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name]);\n      }, this);\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name);\n    value = normalizeValue(value);\n    var oldValue = this.map[name];\n    this.map[name] = oldValue ? oldValue + ', ' + value : value;\n  };\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)];\n  };\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name);\n    return this.has(name) ? this.map[name] : null\n  };\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  };\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value);\n  };\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this);\n      }\n    }\n  };\n\n  Headers.prototype.keys = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push(name);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.values = function() {\n    var items = [];\n    this.forEach(function(value) {\n      items.push(value);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.entries = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push([name, value]);\n    });\n    return iteratorFor(items)\n  };\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true;\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result);\n      };\n      reader.onerror = function() {\n        reject(reader.error);\n      };\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsArrayBuffer(blob);\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsText(blob);\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf);\n    var chars = new Array(view.length);\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i]);\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength);\n      view.set(new Uint8Array(buf));\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false;\n\n    this._initBody = function(body) {\n      this._bodyInit = body;\n      if (!body) {\n        this._bodyText = '';\n      } else if (typeof body === 'string') {\n        this._bodyText = body;\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body;\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body;\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString();\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer);\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer]);\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body);\n      } else {\n        this._bodyText = body = Object.prototype.toString.call(body);\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8');\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type);\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n        }\n      }\n    };\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this);\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      };\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      };\n    }\n\n    this.text = function() {\n      var rejected = consumed(this);\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    };\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      };\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    };\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase();\n    return methods.indexOf(upcased) > -1 ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {};\n    var body = options.body;\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url;\n      this.credentials = input.credentials;\n      if (!options.headers) {\n        this.headers = new Headers(input.headers);\n      }\n      this.method = input.method;\n      this.mode = input.mode;\n      this.signal = input.signal;\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit;\n        input.bodyUsed = true;\n      }\n    } else {\n      this.url = String(input);\n    }\n\n    this.credentials = options.credentials || this.credentials || 'same-origin';\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers);\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET');\n    this.mode = options.mode || this.mode || null;\n    this.signal = options.signal || this.signal;\n    this.referrer = null;\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body);\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, {body: this._bodyInit})\n  };\n\n  function decode(body) {\n    var form = new FormData();\n    body\n      .trim()\n      .split('&')\n      .forEach(function(bytes) {\n        if (bytes) {\n          var split = bytes.split('=');\n          var name = split.shift().replace(/\\+/g, ' ');\n          var value = split.join('=').replace(/\\+/g, ' ');\n          form.append(decodeURIComponent(name), decodeURIComponent(value));\n        }\n      });\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers();\n    // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n    // https://tools.ietf.org/html/rfc7230#section-3.2\n    var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ');\n    preProcessedHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':');\n      var key = parts.shift().trim();\n      if (key) {\n        var value = parts.join(':').trim();\n        headers.append(key, value);\n      }\n    });\n    return headers\n  }\n\n  Body.call(Request.prototype);\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {};\n    }\n\n    this.type = 'default';\n    this.status = options.status === undefined ? 200 : options.status;\n    this.ok = this.status >= 200 && this.status < 300;\n    this.statusText = 'statusText' in options ? options.statusText : 'OK';\n    this.headers = new Headers(options.headers);\n    this.url = options.url || '';\n    this._initBody(bodyInit);\n  }\n\n  Body.call(Response.prototype);\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  };\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''});\n    response.type = 'error';\n    return response\n  };\n\n  var redirectStatuses = [301, 302, 303, 307, 308];\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  };\n\n  exports.DOMException = self.DOMException;\n  try {\n    new exports.DOMException();\n  } catch (err) {\n    exports.DOMException = function(message, name) {\n      this.message = message;\n      this.name = name;\n      var error = Error(message);\n      this.stack = error.stack;\n    };\n    exports.DOMException.prototype = Object.create(Error.prototype);\n    exports.DOMException.prototype.constructor = exports.DOMException;\n  }\n\n  function fetch(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init);\n\n      if (request.signal && request.signal.aborted) {\n        return reject(new exports.DOMException('Aborted', 'AbortError'))\n      }\n\n      var xhr = new XMLHttpRequest();\n\n      function abortXhr() {\n        xhr.abort();\n      }\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        };\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        resolve(new Response(body, options));\n      };\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.onabort = function() {\n        reject(new exports.DOMException('Aborted', 'AbortError'));\n      };\n\n      xhr.open(request.method, request.url, true);\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true;\n      } else if (request.credentials === 'omit') {\n        xhr.withCredentials = false;\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob';\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value);\n      });\n\n      if (request.signal) {\n        request.signal.addEventListener('abort', abortXhr);\n\n        xhr.onreadystatechange = function() {\n          // DONE (success or failure)\n          if (xhr.readyState === 4) {\n            request.signal.removeEventListener('abort', abortXhr);\n          }\n        };\n      }\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n    })\n  }\n\n  fetch.polyfill = true;\n\n  if (!self.fetch) {\n    self.fetch = fetch;\n    self.Headers = Headers;\n    self.Request = Request;\n    self.Response = Response;\n  }\n\n  exports.Headers = Headers;\n  exports.Request = Request;\n  exports.Response = Response;\n  exports.fetch = fetch;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n  return exports;\n\n})({});\n})(__self__);\n__self__.fetch.ponyfill = true;\n// Remove \"polyfill\" property added by whatwg-fetch\ndelete __self__.fetch.polyfill;\n// Choose between native implementation (global) or custom implementation (__self__)\n// var ctx = global.fetch ? global : __self__;\nvar ctx = __self__; // this line disable service worker support temporarily\nexports = ctx.fetch // To enable: import fetch from 'cross-fetch'\nexports.default = ctx.fetch // For TypeScript consumers without esModuleInterop.\nexports.fetch = ctx.fetch // To enable: import {fetch} from 'cross-fetch'\nexports.Headers = ctx.Headers\nexports.Request = ctx.Request\nexports.Response = ctx.Response\nmodule.exports = exports\n","var naiveFallback = function () {\n\tif (typeof self === \"object\" && self) return self;\n\tif (typeof window === \"object\" && window) return window;\n\tthrow new Error(\"Unable to resolve global `this`\");\n};\n\nmodule.exports = (function () {\n\tif (this) return this;\n\n\t// Unexpected strict mode (may happen if e.g. bundled into ESM module)\n\n\t// Fallback to standard globalThis if available\n\tif (typeof globalThis === \"object\" && globalThis) return globalThis;\n\n\t// Thanks @mathiasbynens -> https://mathiasbynens.be/notes/globalthis\n\t// In all ES5+ engines global object inherits from Object.prototype\n\t// (if you approached one that doesn't please report)\n\ttry {\n\t\tObject.defineProperty(Object.prototype, \"__global__\", {\n\t\t\tget: function () { return this; },\n\t\t\tconfigurable: true\n\t\t});\n\t} catch (error) {\n\t\t// Unfortunate case of updates to Object.prototype being restricted\n\t\t// via preventExtensions, seal or freeze\n\t\treturn naiveFallback();\n\t}\n\ttry {\n\t\t// Safari case (window.__global__ works, but __global__ does not)\n\t\tif (!__global__) return naiveFallback();\n\t\treturn __global__;\n\t} finally {\n\t\tdelete Object.prototype.__global__;\n\t}\n})();\n","var _globalThis;\nif (typeof globalThis === 'object') {\n\t_globalThis = globalThis;\n} else {\n\ttry {\n\t\t_globalThis = require('es5-ext/global');\n\t} catch (error) {\n\t} finally {\n\t\tif (!_globalThis && typeof window !== 'undefined') { _globalThis = window; }\n\t\tif (!_globalThis) { throw new Error('Could not determine global this'); }\n\t}\n}\n\nvar NativeWebSocket = _globalThis.WebSocket || _globalThis.MozWebSocket;\nvar websocket_version = require('./version');\n\n\n/**\n * Expose a W3C WebSocket class with just one or two arguments.\n */\nfunction W3CWebSocket(uri, protocols) {\n\tvar native_instance;\n\n\tif (protocols) {\n\t\tnative_instance = new NativeWebSocket(uri, protocols);\n\t}\n\telse {\n\t\tnative_instance = new NativeWebSocket(uri);\n\t}\n\n\t/**\n\t * 'native_instance' is an instance of nativeWebSocket (the browser's WebSocket\n\t * class). Since it is an Object it will be returned as it is when creating an\n\t * instance of W3CWebSocket via 'new W3CWebSocket()'.\n\t *\n\t * ECMAScript 5: http://bclary.com/2004/11/07/#a-13.2.2\n\t */\n\treturn native_instance;\n}\nif (NativeWebSocket) {\n\t['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'].forEach(function(prop) {\n\t\tObject.defineProperty(W3CWebSocket, prop, {\n\t\t\tget: function() { return NativeWebSocket[prop]; }\n\t\t});\n\t});\n}\n\n/**\n * Module exports.\n */\nmodule.exports = {\n    'w3cwebsocket' : NativeWebSocket ? W3CWebSocket : null,\n    'version'      : websocket_version\n};\n","module.exports = require('../package.json').version;\n"],"names":["resolveFetch","customFetch","_fetch","fetch","args","__awaiter","set","target","property","value","receiver","Reflect","desc","base","object","Object","prototype","hasOwnProperty","call","getPrototypeOf","getOwnPropertyDescriptor","writable","defineProperty","_set","isStrict","Error","_construct","Parent","Class","isNativeReflectConstruct","construct","bind","a","push","apply","instance","Function","setPrototypeOf","arguments","_wrapNativeSuper","_cache","Map","undefined","fn","toString","indexOf","TypeError","has","get","Wrapper","this","constructor","create","enumerable","configurable","SOCKET_STATES","CHANNEL_STATES","CHANNEL_EVENTS","TRANSPORTS","CONNECTION_STATE","FunctionsError","message","name","context","FunctionsFetchError","FunctionsRelayError","FunctionsHttpError","FunctionsClient","url","headers","token","Authorization","functionName","invokeOptions","functionArgs","body","_headers","Blob","ArrayBuffer","FormData","JSON","stringify","method","catch","fetchError","response","isRelayError","ok","responseType","_a","split","trim","json","data","blob","formData","text","error","PostgrestTransformBuilder","columns","quoted","cleanedColumns","map","c","test","join","searchParams","column","ascending","nullsFirst","foreignTable","key","existingOrder","count","from","to","keyOffset","keyLimit","signal","allowEmpty","analyze","verbose","settings","buffers","wal","format","options","filter","Boolean","forMediatype","length","PostgrestBuilder","builder","shouldThrowOnError","schema","crossFetch","onfulfilled","onrejected","includes","res","then","status","statusText","parse","countHeader","match","contentRange","_b","parseInt","details","_c","postgrestResponse","hint","code","PostgrestFilterBuilder","append","pattern","values","cleanedValues","s","RegExp","Array","isArray","range","query","config","type","typePart","configPart","entries","forEach","operator","filters","PostgrestQueryBuilder","head","prefersHeaders","unshift","reduce","acc","x","concat","keys","uniqueColumns","Set","onConflict","ignoreDuplicates","DEFAULT_HEADERS","PostgrestClient","relation","URL","DEFAULT_TIMEOUT","REALTIME_PRESENCE_LISTEN_EVENTS","Timer","callback","timerCalc","timer","tries","clearTimeout","setTimeout","Serializer","HEADER_LENGTH","rawPayload","_binaryDecode","buffer","view","DataView","decoder","TextDecoder","_decodeBroadcast","topicSize","getUint8","eventSize","offset","topic","decode","slice","event","ref","payload","byteLength","Push","channel","timeout","sent","timeoutTimer","receivedResp","recHooks","refEvent","rateLimited","_cancelRefEvent","send","_hasReceived","startTimeout","socket","join_ref","_joinRef","_makeRef","_replyEventName","_on","_cancelTimeout","_matchReceive","trigger","_trigger","_off","h","PostgresTypes","RealtimePresence","opts","state","pendingDiffs","joinRef","caller","onJoin","onLeave","onSync","events","diff","newState","syncState","syncDiff","inPendingSyncState","currentPresences","newPresences","leftPresences","currentState","cloneDeep","transformedState","transformState","joins","leaves","presences","newPresenceRefs","m","presence_ref","curPresenceRefs","joinedPresences","joinedPresenceRefs","curPresences","presenceRefsToRemove","obj","func","getOwnPropertyNames","metas","presence","REALTIME_POSTGRES_CHANGES_LISTEN_EVENT","REALTIME_LISTEN_TYPES","REALTIME_SUBSCRIBE_STATES","convertChangeData","record","skipTypes","rec_key","convertColumn","columnName","find","colType","convertCell","noop","charAt","dataType","toArray","bool","toBoolean","float4","float8","int2","int4","int8","numeric","oid","toNumber","jsonb","toJson","timestamp","toTimestampString","abstime","date","daterange","int4range","int8range","money","reltime","time","timestamptz","timetz","tsrange","tstzrange","parsedValue","parseFloat","Number","isNaN","console","log","lastIdx","closeBrace","arr","valTrim","_","val","replace","RealtimeChannel","params","bindings","closed","joinedOnce","pushBuffer","broadcast","ack","self","joinPush","rejoinTimer","_rejoinUntilConnected","reconnectAfterMs","receive","joined","reset","pushEvent","_onClose","_remove","_onError","reason","_isLeaving","_isClosed","errored","scheduleTimeout","_isJoining","reply","e","accessTokenPayload","postgres_changes","r","accessToken","access_token","updateJoinPayload","_rejoin","serverPostgresFilters","setAuth","clientPostgresBindings","bindingsLen","newPostgresBindings","i","clientPostgresBinding","table","serverPostgresFilter","unsubscribe","id","Promise","resolve","_push","updatePayload","leaving","onClose","close","destroy","leavePush","leave","_canPush","_event","_ref","typeLower","toLocaleLowerCase","handledPayload","_onMessage","bindId","bindEvent","ids","_d","_e","_f","postgresChanges","enrichedPayload","commit_timestamp","eventType","new","old","errors","_getPayloadRecords","joining","binding","isEqual","isConnected","_isJoined","_leaveOpenTopic","resend","records","Transformers","old_record","obj1","obj2","k","RealtimeClient","endPoint","channels","transport","w3cwebsocket","heartbeatIntervalMs","heartbeatTimer","pendingHeartbeatRef","logger","conn","sendBuffer","serializer","stateChangeCallbacks","open","eventsPerSecondLimitMs","inThrottle","websocket","eventsPerSecond","Math","floor","encode","reconnectTimer","disconnect","connect","_endPointURL","binaryType","onopen","_onConnOpen","onerror","_onConnError","onmessage","_onConnMessage","onclose","_onConnClose","clearInterval","all","kind","msg","readyState","connecting","Connecting","Open","closing","Closing","Closed","connectionState","chan","result","_throttle","newRef","dupChannel","_appendParams","assign","vsn","rawMessage","_isMember","_flushSendBuffer","setInterval","_sendHeartbeat","_triggerChanError","prefix","URLSearchParams","eventsPerSecondLimit","StorageError","__isStorageError","isStorageError","StorageApiError","StorageUnknownError","originalError","_getErrorMessage","err","error_description","handleError","reject","Response","Res","_getRequestParams","parameters","_handleRequest","fetcher","noResolveJson","post","put","remove","DEFAULT_SEARCH_OPTIONS","limit","sortBy","order","DEFAULT_FILE_OPTIONS","cacheControl","contentType","upsert","StorageFileApi","bucketId","path","fileBody","fileOptions","String","cleanPath","_removeEmptyFolders","_path","_getFinalPath","uploadOrUpdate","fromPath","toPath","sourceKey","destinationKey","Key","expiresIn","downloadQueryParam","download","signedUrl","encodeURI","signedURL","paths","datum","publicUrl","prefixes","StorageBucketApi","public","StorageClient","fetchWithAuth","supabaseKey","getAccessToken","HeadersConstructor","Headers","CrossFetchHeaders","input","init","isBrowser","window","getParameterByName","location","href","results","exec","decodeURIComponent","getItemAsync","storage","getItem","removeItemAsync","removeItem","Deferred","promise","promiseConstructor","rej","decodeJWTPayload","parts","base64Url","atob","charCodeAt","ReferenceError","Buffer","decodeBase64URL","AuthError","__isAuthError","isAuthError","AuthApiError","AuthUnknownError","CustomAuthError","AuthSessionMissingError","AuthInvalidCredentialsError","AuthImplicitGrantRedirectError","AuthRetryableFetchError","NETWORK_ERROR_CODES","maybeResponse","_request","jwt","qs","redirectTo","queryString","xform","_sessionResponse","session","refresh_token","expires_in","hasSession","expires_at","round","Date","now","user","_userResponse","_ssoResponse","_generateLinkResponse","action_link","email_otp","hashed_token","redirect_to","verification_type","rest","__rest","properties","GoTrueAdminApi","mfa","listFactors","_listFactors","deleteFactor","_deleteFactor","email","new_email","newEmail","attributes","users","uid","userId","NETWORK_FAILURE","globalThis","localStorage","setItem","__magic__","polyfillGlobalThis","DEFAULT_OPTIONS","storageKey","autoRefreshToken","persistSession","detectSessionInUrl","GoTrueClient","stateChangeEmitters","networkRetries","refreshingDeferred","initializePromise","inMemorySession","localStorageAdapter","admin","initialize","verify","_verify","enroll","_enroll","unenroll","_unenroll","challenge","_challenge","challengeAndVerify","_challengeAndVerify","getAuthenticatorAssuranceLevel","_getAuthenticatorAssuranceLevel","_initialize","_isImplicitGrantFlow","_getSessionFromUrl","_removeSession","redirectType","_saveSession","_notifyAllSubscribers","_recoverAndRefresh","_handleVisibilityChange","credentials","password","emailRedirectTo","gotrue_meta_security","captcha_token","captchaToken","phone","_handleProviderSignIn","provider","scopes","queryParams","create_user","shouldCreateUser","provider_id","providerId","domain","skip_http_redirect","currentSession","maybeSession","_isValidSession","_callRefreshToken","getSession","sessionData","sessionError","userError","timeNow","expiresAt","hasExpired","_decodeJWT","exp","_refreshAccessToken","getUser","token_type","error_code","provider_token","provider_refresh_token","hash","signOut","random","subscription","delete","refreshToken","_getUrlForProvider","Infinity","EXPIRY_MARGIN","MAX_RETRIES","refreshTokenTimer","refreshDurationBeforeExpires","_startAutoRefreshToken","_persistSession","unref","addEventListener","document","visibilityState","urlParams","encodeURIComponent","factorId","friendly_name","friendlyName","factor_type","factorType","issuer","totp","qr_code","challenge_id","challengeId","challengeData","challengeError","factors","factor","currentLevel","nextLevel","currentAuthenticationMethods","aal","amr","SupabaseAuthClient","DEFAULT_GLOBAL_OPTIONS","DEFAULT_DB_OPTIONS","DEFAULT_AUTH_OPTIONS","DEFAULT_REALTIME_OPTIONS","SupabaseClient","supabaseUrl","_supabaseUrl","realtimeUrl","authUrl","storageUrl","urlParts","functionsUrl","defaultStorageKey","hostname","defaults","dbOptions","db","authOptions","auth","realtimeOptions","realtime","globalOptions","global","applySettingDefaults","_initSupabaseAuthClient","_getAccessToken","_g","_initRealtimeClient","_h","_listenForAuthEvents","SupabaseStorageClient","rpc","getChannels","removeChannel","removeAllChannels","authHeaders","apikey","onAuthStateChange","_handleTokenChanged","source","changedAccessToken","createClient","__self__","F","DOMException","exports","support","Symbol","viewClasses","isArrayBufferView","isView","normalizeName","toLowerCase","normalizeValue","iteratorFor","items","iterator","next","shift","done","header","consumed","bodyUsed","fileReaderReady","reader","onload","readBlobAsArrayBuffer","FileReader","readAsArrayBuffer","bufferClone","buf","Uint8Array","Body","_initBody","_bodyInit","_bodyText","isPrototypeOf","_bodyBlob","_bodyFormData","_bodyArrayBuffer","rejected","arrayBuffer","readAsText","readBlobAsText","chars","fromCharCode","readArrayBufferAsText","oldValue","thisArg","methods","Request","mode","upcased","toUpperCase","normalizeMethod","referrer","form","bytes","parseHeaders","rawHeaders","line","bodyInit","clone","redirectStatuses","redirect","RangeError","stack","request","aborted","xhr","XMLHttpRequest","abortXhr","abort","getAllResponseHeaders","responseURL","responseText","ontimeout","onabort","withCredentials","setRequestHeader","onreadystatechange","removeEventListener","polyfill","ponyfill","ctx","module","naiveFallback","__global__","_globalThis","require","NativeWebSocket","WebSocket","MozWebSocket","websocket_version","W3CWebSocket","uri","protocols","prop"],"sourceRoot":""}